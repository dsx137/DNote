---
---

# 树

>**Tree**

## 定义

>树是由$n(n\geqslant0)$个有限节点组成的具有**层次关系**的集合。\
>把它叫做“树”是因为它看起来像一棵倒挂的树\
>也就是说它是根朝上，而叶朝下的。

---

## 通用名词

+ `节点（结点）`：树的最小单元
+ `节点的度`：子树数量
+ `树的度`：度最大的那个节点的度
+ `叶子（终端节点）`：没有子树的节点
+ `非终端节点（分支节点）`：有子树的节点。除根节点以外的非终端节点称为内部节点
+ `双亲，孩子，兄弟，祖先，子孙，堂兄弟`：同层的都叫堂兄弟，其他不解释
+ `层次`：根为第一层，孩子层次=双亲层次+1
+ `深度`：树的最大层次
+ `有序树和无序树`：若将树中每个结点的各子树**看成**是从左到右有次序的，则为有序树，否则为无序树
+ `空树`：一个节点都没有的树

## 存储结构

[双亲表示法](http://data.biancheng.net/view/196.html)\
[孩子表示法](http://data.biancheng.net/view/197.html)

***孩子兄弟表示法（二叉树表示法）***\
<http://data.biancheng.net/view/198.html>\
如下：\
原树为A，转换后的二叉树为B\
在B中\
B中节点的左子树代表A中源节点的子树\
B中节点的右子树代表A中源节点的兄弟

```cpp
//---树的二叉链表存储表示---//
typedef struct CSNode{
    ElemType data;
    struct CSNode *firstchild, *nextsibling;
}CSNode, *CSTree;
```

## 遍历方法

没有中序遍历是因为节点的度不一致，树的度不一定最大为2

+ 先序遍历：
  + **访问根**；
  + 从左到右，访问每棵子树
+ 后序遍历：
  + 从左到右，访问每棵子树；
  + **访问根**。

---

## 二叉树

### 定义

度$\leqslant 2$的有序树

```cpp
//---二叉树的顺序存储表示---//
#define MAXTSIZE 100
typedef TElemType SqBiTree[MAXTSIZE];
SqBiTree bt;

//---二叉树的二叉链表存储表示---//
typedef struct BiTNode{
    TElemType data;
    struct BiTNode *lchild, *rchild;
}BiTNode, *BiTree;
```

### 名词

+ `完美二叉树`：除了叶子，每个节点度都为2，叶子都在同一层
  + 国内叫“满二叉树”
+ `完满二叉树`：除了叶子，每个节点度都为2
+ `完全二叉树`：叶子层可以不满的完美二叉树，并且叶子向左靠拢

![image](https://img-blog.csdnimg.cn/a3d4abe364a0446aa6d9418a0e38a29b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAWWFrZTE5NjU=,size_20,color_FFFFFF,t_70,g_se,x_16)

+ `二叉排序树、二叉搜索树、二叉查找树`：左子树任意节点值<根节点值<右子树任意节点值

### 二叉树的遍历

+ 前序遍历
  1. **访问根**
  2. 访问左子树
  3. 访问右子树
+ 中序遍历
  1. 访问左子树
  2. **访问根**
  3. 访问右子树
+ 后序遍历
  1. 访问左子树
  2. 访问右子树
  3. **访问根**

>查找树的中序遍历是有序数列

给定中序+前/后序则可以确定二叉树结构\
***前提：元素不重复***\
但是前序+后序不行，因为无法区分左右子树\
中序提供左右子树区分，前后序提供根节点

规则：待补充……

### 线索二叉树

#### 定义

遍历的前驱和后继的信息就叫线索\
线索二叉树就是把线索存入每个节点里的二叉树\
这样在遍历的时候空间复杂度就是$O(1)$了（因为可以不使用栈）

教科书里为了省空间，就只在度小于2的节点存储\
并且只在没有子树的一边存储线索

`LTag==0 ? lchild=左孩子 : lchild=前驱`\
`RTag==0 ? lchild=右孩子 : lchild=后继`

```cpp
//---二叉线索数树存储表示---//
typedef struct BiThrNode{
    TElemType data;
    struct BiThrNode *lchild, *rchild;
    int LTag, RTag;
}BiThrNode, *BiThrTree;
```

不储存相应线索的节点在线索二叉树中：

|线索二叉树|前序|中序|后序|
|-|-|-|-|
|找前驱    |F  |T   |T   |
|找后继    |T  |T   |F   |

只有中序线索二叉树是完善的
后序线索二叉树仍需栈来遍历（纯纯的124）

### 哈夫曼树

<http://c.biancheng.net/view/3398.html>

#### 定义

当用n个结点（都做叶子结点且都有各自的权值）试图构建一棵树时\
如果构建的这棵树的带权路径长度最小\
称这棵树为“哈夫曼树”（“最优二叉树”，“赫夫曼树”）。

![image](data:image/png;base64,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)
>这颗树的带权路径长度为：
>$WPL = 7\times1 + 5\times2 + 2\times3 +4\times3$

```cpp
//---哈夫曼树的存储表示---//
typedef stuct{
    int weight;
    int parent, lchild, rchild;
}HTNode, *HuffmanTree;
```

#### 名词

+ `路径`：在一棵树中，一个结点到另一个结点之间的通路，称为路径
+ `路径长度`：在一条路径中，每经过一个结点，路径长度都要加1
+ `结点的权(Weight)`：结点上的一个有意义的数值
+ `结点的带权路径长度`：根结点到该结点的路径长度$\times$该结点的权
+ `树的带权路径长度(WPL)`：所有叶子结点的带权路径长度之和

#### 构建

不对左右子树做规定，所以\
**对于相同的一组权值，哈夫曼树不唯一**

对于给定的有各自权值的 n 个结点：

1. 选出两个权值最小的结点组成一个新的二叉树，根结点权值为两权值的和
2. 在原有的n个权值中排除最小的两个权值，同时将新二叉树根节点的权值加入到 n–2 个权值的行列中
3. 重复1和2，直到所有结点构建成一棵二叉树

![image](data:image/png;base64,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)

这里其实有个容易陷入的误区，就是\
选了两个节点组成树了之后，下一次不一定选这棵树的根节点来组队\
应该仍然选剩下权值里最小的两个\
这样构建的哈夫曼树就不是图中看起来那样往一边倒的样子了

#### 编解码

##### (无)前缀编码

要设计长度不等的编码\
则必须使任一字符的编码都不是另一个字符的编码的前缀

##### 编码

什么样的前缀码能使得电文总长最短？\
哈夫曼编码

1. 将字符作为哈夫曼树的叶子结点，出现次数作为权值
2. 构造哈夫曼树
3. 结点的左分支标0，右分支标１。
4. 将根到叶子的路径上的标号连接起来，就是该叶子代表的字符的编码．

构建完成后\
则：

+ $\because\forall x,y\lbrace x,y\in leaf\space nodes\rbrace :\space P(x,y)=x不为y的子节点$\
$\therefore 前缀不重复$
+ 权值越大，离根节点越近，编码就越短

对于编解码来说，前后所用的哈夫曼树需要完全一致

---

## 森林

$m(m\geqslant0)$个不相交的树组成的集合

### 森林和二叉树的转换

用二叉树表示法，先将所有树转换为二叉树\
然后将每棵树的根节点看成兄弟\
从第一棵树开始，每个根节点的右子树都是森林中的另一棵树

~~其实我感觉这种混沌的表示方法应该斜着看，这样兄弟节点就在一行上面了~~

![image](https://img-blog.csdnimg.cn/54dbe2d99f314ae689513142679e31a1.png#pic_center)

森林的遍历（递归定义）

+ 前序遍历
  1. **访问根**
  2. 访问子树
  3. 访问剩余的树构成的森林
+ 中序遍历
  1. 访问子树
  2. **访问根**
  3. 访问剩余的树构成的森林
+ 后序遍历
  1. 访问子树
  2. 访问剩余的树构成的森林
  3. **访问根**
