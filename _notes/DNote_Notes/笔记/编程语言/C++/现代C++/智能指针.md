---
---

# 智能指针

与智能指针对应的是裸指针\
智能指针的出现主要是为了解决内存泄漏的问题\
头文件为`<memory>`

注意：

+ `make_***`的语法在C++14之后才引入
+ auto_ptr在C++11之后被舍弃

---

## 声明和初始化

```cpp
#include <memory>

void main(void)
{
    std::unique_ptr<int> p1;
    p1 = make_unique<int>(100);//100为构造函数的参数（初始化）

    std::unique_ptr<int> p2 {new int(100)};

    std::unique_ptr<int> p3 {make_unique<int>(100)};//如上，但是效率更高，在11之前的版本更安全
    //---------Separator---------//
    std::shared_ptr<int> p4;
    p4 = make_shared<int>(100);

    std::shared_ptr<int> p5 {new int(100)};

    std::shared_ptr<int> p6 {make_shared<int>(100)};
}
```

[关于{}的初始化应用](https://blog.csdn.net/rubikchen/article/details/121888274)<——~~其实这篇文章结构是一拖四，不过我暂时没有打算写这部分内容，所以将就用一下~~

## unique_ptr

>唯一指针

### 逻辑

不能复制，独占

### 注意事项

+ 把unique_ptr赋值为nullptr会释放原指针空间

## shared_ptr

>共享指针

### 逻辑

共享指针会记录指向同一个内存空间的共享指针个数\
当最后一个共享指针被释放时，其指向的空间也会被释放\
~~其实听起来蛮简单的，实现好像也蛮简单的，提示：自定义指针运算符，模板类，构造函数，析构函数~~

### 注意事项

+ 不要使用同一个原始指针进行默认构造`shared_ptr<int> p2(num)`
  + 正确方法是`shared_ptr<int> p2(p1)`
+ 会有一点点额外性能开销

### weak_ptr

## 小东西

### 函数

+ 通用
  + `ptr.get()`会返回一个对应的裸指针
  + `ptr.reset()`会将ptr指向NULL，（并且原share计数减1）
    + `reset()`可以有参数，参数为指向的新空间
  + `ptr.release()`解绑，返回裸指针（并且原share计数减1）
  + `ptr.bool()` 判断是否拥有裸指针
+ shared_ptr
  + `ptr.use_count()`返回引用计数
+ unique_ptr

[CSDN - C++ 智能指针](https://blog.csdn.net/a777122/article/details/124051672)

### 自定义删除行为

+ shared_ptr

```cpp
void close_file(FILE* fp){
    if(fp == nullptr) return;
    fclose(fp);
    cout << "File closed." << endl;
}
int main(){
    FILE* fp = fopen("data.txt","w");
    shared_ptr<FILE> sfp {fp,close_file};//直接在第二个参数写上删除器
    if(sfp == nullptr)
        cerr << "Error opening file." << endl;
    else cout << "File opened." << endl;
}
```

### 共同注意事项

+ 不分配任何值时指向NULL
+ 仅提供->，*，==运算符，没有+，-，++，--，[]等运算符
+ 不要使用栈指针（因为智能指针使用delete释放空间，所以在构造时也需要new出来的空间）

### 循环引用
