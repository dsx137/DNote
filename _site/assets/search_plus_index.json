{"/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/@%E5%BA%8F%E8%A8%80",
    "body": "写作规范 搞了N天，终于把gitbook主题魔改成了这个样子 太吓人了 以后如果再有机会学前端 我就把这个模板pr到gitbook 或者fork一个带目录树的分支到jekyll themes里面 目录快写好了 就这样吧 本笔记系统是使用了ruby编写的jekyll作为框架，gitbook主题作为模板 魔改之后的一个前端页面 要想本地修改或者编辑的话 建议安装一个jekyll作为本地的调试工具 Jekyll官网 安装： 安装Ruby 在CMD中输入gem install jekyll cd到工程所在目录，输入jekyll s 访问http://localhost:4000"
  },"/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/Markdown": {
    "title": "Markdown",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/Markdown",
    "body": "Markdown Markdown除了posts文件夹以外的文件必须写metadata，不然jekyll读不出来 换行要在行尾加\\ markdownlint的配置文件是.markdownlint.jsonc，谨慎更改 HTML内的Markdown 如果HTML标记具有markdown =”0”属性,则不会在该HTML标记内部进行解析(除了解析HTML span标记). 如果HTML标记具有markdown =”1”属性,则标记的内容将被解析为span级别元素. 如果HTML标记具有markdown =”block”属性,则会发出警告,因为HTML跨度不能包含块级元素,并且该属性将被忽略. 如果HTML标记具有markdown =”span”属性,则标记的内容将被解析为span级别元素. 使用如下代码来屏蔽掉Jekyll Kramdown对code解析 &lt;span style='display: none'&gt;{::nomarkdown}&lt;/span&gt; &lt;!-- your code --&gt; &lt;span style='display: none'&gt;{:/nomarkdown}&lt;/span&gt;"
  },"/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E5%9B%BE%E7%89%87": {
    "title": "图片",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E5%9B%BE%E7%89%87",
    "body": "图片 建议使用PicGo+SM.MS作为图床工具上传图片"
  },"/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E7%9A%84%E7%AC%A6%E5%8F%B7": {
    "title": "文件开头的符号",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E6%96%87%E4%BB%B6%E5%BC%80%E5%A4%B4%E7%9A%84%E7%AC%A6%E5%8F%B7",
    "body": "文件开头的符号 0. 表示该有序分类第一顺位的文章，一般是引言和介绍等 @ 表示该无序分类第一顺位的文章，一般是引言和介绍等 ※ 复杂或者不是主干部分的东西，起一个辅助标签再分类的作用"
  },"/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E9%9B%B6%E6%95%A3": {
    "title": "零散",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/@%E5%86%99%E4%BD%9C%E8%A7%84%E8%8C%83/%E9%9B%B6%E6%95%A3",
    "body": "零散 改变单页面最大宽度在md文件末尾加上： &lt;style&gt;.page-inner {max-width: 这里填像素数px !important;}&lt;/style&gt; 在引入图片时需要添加描述 同一目录下不要同时出现文件夹和文件（如果我觉得必要，我可以修改代码，让文件夹排到文件前面，但是我觉得这样不好，不够整洁，所以不打算这么做，还是分开放置更明晰） 应当尽量减少文件夹的嵌套使用，并且使分类足够明确和合理 $\\LaTeX$公式过长请分段inline书写，如下 $A+B$ $+C+D$ $+E+F$ $+G+H$ $+I+J$ $+K+L$ $+M+N$ $+O+P$ $+Q+R$ $+S+T$ $+U+V$ $+W+X$ $+Y+Z$ (Katex似乎没有这个问题，等能解决了就把这条删掉)"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Git": {
    "title": "Git",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Git",
    "body": "Git 非常难的东西 基础流程 这个是测试内容"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Github%20API": {
    "title": "Github api",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Github%20API",
    "body": "Github API 一个用于获取github信息的url系统 一些格式 https://api.github.com/repos/这里填用户/这里填仓库/ 查看文件在后添加contents/path 查看提交在后添加commits/sha 一些东西 查看api速率限制"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Jekyll": {
    "title": "Jekyll",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Jekyll",
    "body": "Jekyll 就是一拖四 要先安装gem,ruby，然后cd到文件夹，bundle install安装前置 输入jekyll s启动，版本不兼容用bundle exec jekyll s启动 不懂github为什么要支持jekyll _config.yml collections: pages: output: true permalink: /:collection/:path sort_by: lesson output: true 表示这个合集下每个文件都会被渲染成独立的 html 文件 sort_by: lesson 表示合集内容会根据 lesson 字段来排序 permalink 表示在output文件夹（默认应该都是_site）的相对路径 变量 :collection 嗯，就是上面你设置的collection名字 :path 在原文件夹里的相对路径 :title 这个还没明白取决于什么 :year :month :day 这个是metadata里的data，posts里面是文件名前半部分 :output_ext output后的后缀 :categories 这个是metadata里写的 Github 这个更是重量级 要把url设置成域名，baseurl设置成repo名，然后还要打开github仓库的actions github_page就会给你构建 基本是个模板就能挂github 网上说的那些什么参数啊都不对"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/LaTeX": {
    "title": "Latex",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/LaTeX",
    "body": "$\\LaTeX$ MathJax符号参考"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Markdown": {
    "title": "Markdown",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/Markdown",
    "body": "Markdown 小东西 markdown可以用base64存图片 ![image][base64] 像这样 可以在文件末尾使用[var]:base64来存储图片 以在正文中使用![image][var] 资料网站 md代码块高亮支持标注 Vscode的下的快捷键(基于 Markdown)"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/gost": {
    "title": "Gost",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/gost",
    "body": "gost 非常好程序，代理非常好，爱来自NAT 手册 端口转发 其中，A转发到B的含义是，可以通过访问A来访问B"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F": {
    "title": "正则表达式",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E5%85%B6%E4%BB%96/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F",
    "body": "正则表达式 菜鸟 理解^和$ 又好又难的东西 功能是检索特定字符组合 有这么一种想法 既然人能机械地识别某种字符组合 那为什么电脑就不行呢？ 正则表达式就是这样的一种东西 一些东西 .* 匹配任意长度的任意字符，匹配多次（贪婪） .*? 匹配任意长度的任意字符，但是只匹配一次（非贪婪） 区别： 原字符串： cccbopbccc–cccbopbccc b.*b b.*?b 共找到 1 处匹配 共找到 2 处匹配 bopbccc–cccbopb bopb, bopb .+ .+? 同上，但是至少有一个字符 [^\\w\\s] 匹配符号"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/@%E5%AF%BC%E8%88%AA/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/@%E5%AF%BC%E8%88%AA/@%E5%BA%8F%E8%A8%80",
    "body": "数学 数学不是领域非常分明的 本文也只是做了一个粗略的分类 其实数学中的各个领域几乎都是互相融合的 不同的人有不同的分类方式 以下是wiki的分类： 基础数学 数理逻辑 集合论 范畴论 计算理论 纯粹数学 数量 结构 数论 图论 组合数学 序理论 代数 空间 几何 三角学 微分几何 拓扑 分形 测度论 变化 微积分 向量分析 微分方程 动力系统 混沌理论 复分析 应用数学 物理数学 数学流体力学 数值分析 最优化 概率论 统计学 计量金融 博弈论 数理经济学 生物数学 数理化学 密码学"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/0.%E5%BC%95%E5%85%A5": {
    "title": "0.引入",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/0.%E5%BC%95%E5%85%A5",
    "body": "概率论 闲谈 学校教的有些坑 比如概率的定义 实际上有三次，分别是古典定义，统计定义，公理化定义 还有为什么概率为0的事件也能发生 这关乎到苏联数学家安德雷·柯尔莫哥洛夫基于测度论对概率论进行的公理化 基本概念 必然现象 可预知 结果只有一个 随机现象 不可预知 结果不止一个 在大量实验下会出现规律性，叫统计规律"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/1.%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87": {
    "title": "1.随机事件及其概率",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/1.%E9%9A%8F%E6%9C%BA%E4%BA%8B%E4%BB%B6%E5%8F%8A%E5%85%B6%E6%A6%82%E7%8E%87",
    "body": "随机事件及其概率 基本概念 试验 随机试验E：符合下列规则的试验 在相同条件下可重复进行 结果不止一个，但可知所有结果 不能预知出现哪种结果 样本空间S：试验的所有结果集合 样本点（基本事件）e：集合中的一个可能的结果 每次试验只有一个样本点出现 事件 随机事件A：简称事件，样本空间S的子集，也就是一些可能情况（样本点）的集合 频率：$R_n(A) = \\displaystyle\\frac{f_A}{n}$，$f_A$为频数（在n次试验中发生的次数）， 概率：$P(A)$，度量事件发生的可能性大小的值 特殊事件 必然事件S 不可能事件∅ 独立事件：若$P(AB)=P(A)P(B)$，则A、B相互独立，A发生不会影响B发生 （注意，独立事件有且仅有交集为两概率相乘这一项定义，两独立事件除空集外是必然有交集的） 关系与运算 运算法则为集合的运算法则 关系 包含 A发生B一定发生，B发生A不一定发生 $A\\subset B$（集合的包含） 相等 A就是B $A\\subset B 且 B\\subset A$（集合的相等） $A = B$ 互斥 A发生时B不发生 $A\\cap B = \\emptyset$ 对立 要么A发生，要么B发生 $A+B=1$ $B=\\overline{A}$ 运算 积事件（交集） C为A、B同时发生 $C = A\\cap B$ 和事件（并集） C为A、B任意一个发生 $C = A\\cup B$ 差事件 C为A发生时B不发生 $C = A-B$ 古典概率模型 样本点有限并且等可能发生的试验 $P(A)=\\displaystyle\\frac{count(A)}{count(S)}$ count(X)为事件的样本点总个数 求样本点个数可能会需要组合数学 几何概率模型 样本点无限且等可能发生的试验 为古典概率模型的推广，待补充 条件概率 B发生时A发生的概率 $P(A\\mid B) = \\displaystyle\\frac{P(AB)}{P(B)}$ 乘法定理 $P(AB) = P(A\\mid B)\\times P(B)$ 当$A\\subset B$时，P(A)$\\times$P(B)并不代表任何特定的概率 此时它只是两个概率的乘积，没有特殊的意义 全概率公式 有$S_1$，$S_2$，……，$S_n$，且互不相容（为划分） 且$P(S_i)&gt;0$，$\\sum_{i=1}^{n}Si=1$，则： $P(A)$ $=P(A\\mid S_1)P(S_1)$ $+P(A\\mid S_2)P(S_2)$ $+……$ $+P(A\\mid S_n)P(S_n)$ 贝叶斯公式 Bayes 全概率公式的应用 有$S_1$，$S_2$，……，$S_n$，且互不相容（为划分） 且$P(S_i)&gt;0$，$\\sum_{i=1}^{n}Si=1$，$P(A)&gt;0$，则： $P(S_i\\mid A)$ $=\\displaystyle\\frac{P(AS_i)}{P(A)}$ $=\\displaystyle\\frac{P(A\\mid S_i)\\times P(S_i)}{\\sum_{j=1}^{n} P(A\\mid S_j)\\times P(S_j)}$"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/2.%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83": {
    "title": "2.随机变量及其分布",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E5%BA%94%E7%94%A8%E6%95%B0%E5%AD%A6/%E6%A6%82%E7%8E%87%E8%AE%BA/2.%E9%9A%8F%E6%9C%BA%E5%8F%98%E9%87%8F%E5%8F%8A%E5%85%B6%E5%88%86%E5%B8%83",
    "body": "随机变量及其分布 基本概念 随机变量X：$X_{A}(e)$，表示在事件A中的随机变量 定义 用符号语言来说，在试验E下的样本空间S，对于任意事件e（$\\forall e\\in S$），有唯一实数$X(e)$对应。称$X(e)$为随机变量 通俗地说，随机变量是将试验中的样本点赋予数值，来量化概率的一个变量（函数） 类型 离散型随机变量：定义域有限个或可列无穷多个 连续型随机变量：无穷多个且充满区间 ※特性和解释 随机变量是一个定义在样本空间上的实值函数，它将试验的每个可能结果映射到一个实数 不是一个固定的值，而是一个具有概率分布的变量 定义域为事件集，值域为对应事件概率 它的函数也是一个随机变量（X为随机变量，Y=2X，Y也是随机变量），只要它是可测的 分布 描述随机变量或随机事件的概率性质的一种数学方法 分布律和概率密度函数是描述分布的一般形式 离散型 分布律 定义 $P\\lbrace X=X_k\\rbrace=p_k，k=1,2,\\cdots$ （这里k是X的下标，并不是X要取的值） 非负性：$p_k\\ge 0$ 归一性：$\\sum_{k=1}^{\\infty}p_k=1$（所有样本点概率和为1） 表现形式 分布列（表格） \\[\\begin{array}{c|ccccccccc} \\text{$X$} &amp; x_1 &amp; x_2 &amp; \\cdots &amp; x_k \\\\ \\hline \\text{$p_x$} &amp; p_1 &amp; p_2 &amp; \\cdots &amp; p_k \\\\ \\end{array} \\hspace{5000px}\\] 线条图 概率直方图 分布类型 二项分布 设E是只有两种可能结果的试验（伯努利试验），重复n次(n重伯努利试验) $P\\lbrace X=k\\rbrace =C_{n}^{k}\\space p^k(1-p)^k$ 记为$X\\sim B(n,p)$ 01分布（伯努利分布） 是二项分布的特殊情况（n=1） 记为$X\\sim(0-1)$或$X\\sim B(1,p)$ 泊松分布 $P\\lbrace X=k\\rbrace =\\displaystyle\\frac{\\lambda^ke^{-\\lambda}}{k!}，k=0,1,2,\\cdots$ 记为$X\\sim \\pi(\\lambda)$ 连续型 概率密度函数 满足以下条件的$f(x)$： 概率非负 $f(x)\\ge 0，-\\infty&lt;x&lt;\\infty$ 所有样本点概率和为1 $\\int_{-\\infty}^{\\infty}f(x)dx=1$ 区间面积表示该区间的概率，y值表示概率在此点的密度 $P\\lbrace a\\le X\\le b\\rbrace = \\int_{a}^{b}f(x)dx$ 分布类型 均匀分布 \\[\\begin{align*} f(x)= \\left \\{ \\begin{array}{ll} \\displaystyle\\frac{1}{b-a} &amp;, a&lt;x&lt;b\\\\ 0 &amp;,其他 \\end{array} \\right. \\end{align*}\\] 指数分布 \\[\\begin{align*} f(x)= \\left \\{ \\begin{array}{ll} \\displaystyle\\frac{1}{\\theta}e^{-x/\\theta} &amp;,x&gt;0\\\\ 0 &amp;,其他 \\end{array} \\right. \\end{align*}\\] 正态分布 \\[f(x)=\\displaystyle\\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-(x-\\mu)^2/(2\\sigma^2)}，-\\infty &lt; x &lt;\\infty\\] 分布函数 二维随机变量 补充"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/@%E5%BA%8F%E8%A8%80",
    "body": "抽象代数 也称近世代数 抽象代数简言之就是群、环、域的故事。 群、环等概念不是离散数学独有的 离散数学也不是数学领域的概念，它是计算机领域的概念 离散数学 = 集合论基础 + 图论基础 + 抽象代数（近世代数）基础 + 数论基础"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4": {
    "title": "群",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E4%BB%A3%E6%95%B0/%E6%8A%BD%E8%B1%A1%E4%BB%A3%E6%95%B0/%E7%BE%A4",
    "body": "群 有以下几个规则： G1:乘法结合律 G2:幺元（单位元） G3:逆元 G4:乘法交换律"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E6%95%B0%E8%AE%BA/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0": {
    "title": "最大公因数",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E5%AD%A6/%E7%BA%AF%E7%B2%B9%E6%95%B0%E5%AD%A6/%E7%BB%93%E6%9E%84/%E6%95%B0%E8%AE%BA/%E5%88%9D%E7%AD%89%E6%95%B0%E8%AE%BA/%E6%9C%80%E5%A4%A7%E5%85%AC%E5%9B%A0%E6%95%B0",
    "body": "最大公因数 欧几里得算法 又称辗转相除法 求$a,b$的最大公因数的一个方法 原理 \\[\\begin{gather*} a/b=q……r=&gt;a=qb+r\\\\ (a,b)=(b,r)\\\\ (0,b)=b \\end{gather*}\\] 过程 $a\\div b=q……r$，即$a=q\\times b+r$ 其中$q(quotient)$为商，$r(remainder)$为余数 再将除数和余数做新一轮求余运算 直到求得的余数为0 $(a,b)=最终的除数$ 例： \\[\\begin{align*} &amp;(被除数，除数)\\\\ =&amp;(172,46)\\\\ =&amp;(46,34)\\\\ =&amp;(34,12)\\\\ =&amp;(12,10)\\\\ =&amp;(10,2)\\qquad(此时余数为0，(a,b)=2)\\\\ \\end{align*}\\] C++代码 #include&lt;bits/stdc++.h&gt; using namespace std; void main() { int a = 0, b = 0, r = 1; cin &gt;&gt; a &gt;&gt; b; if (b &gt; a) { b = b - a; a = a + b; b = a - b; } while (a % b != 0) { r = a % b; a = b; b = r; } cout &lt;&lt; b; } 简明证明 $有a,b,r三个数$ $分别是式子中的被除数，除数和余数：$ \\[(b,a)=x\\\\ (b,r)=y\\] $由原式可得：$ \\[\\begin{align*} &amp;a=qb+r\\\\ =&gt;&amp;a'x=qb'x+r \\qquad\\small((b,a)=x)\\\\ =&gt;&amp;r=(a'-qb')x \\end{align*}\\] $可得x\\mid r，同理：$ \\[\\begin{align*} &amp;a=qb+r\\\\ =&gt;&amp;a=qb'y+r'y \\qquad\\small((b,r)=y)\\\\ =&gt;&amp;a=(qb'+r')y \\end{align*}\\] $可得y\\mid a，即$ \\[(b,a)|r\\\\ (b,r)|a\\\\\\] $设A,B,R分别为a,b,c的质因数集合$ $则有：$ \\[B\\cap A\\subseteq R\\\\ B\\cap R\\subseteq A\\\\ \\therefore B\\cap A=B\\cap R\\\\\\] $得证.$ 裴蜀等式 又名贝祖定理，裴蜀恒等式等 定理内容 $(a,b)=sa+tb$ 求系数 Why？ （这里有个误区，裴蜀等式是一个定理，也就是说没有所谓的原理，只有证明过程） 就是欧几里得算法的一个应用 真别按着教科书倒着来 咱正着看 $设a=172，b=46$ \\[\\begin{align*} a=&amp;3\\times b +34\\\\ b=&amp;1\\times 34 +12\\\\ 34=&amp;2\\times 12+10\\\\ 12=&amp;1\\times 10+2\\\\ 10=&amp;5\\times 2+0\\\\ \\end{align*}\\] $则$ \\[\\begin{align*} &amp;34=a-3b\\\\ =&gt;&amp;12=b-(a-3b)=4b-a\\\\ =&gt;&amp;10=(a-3b)-2(4b-a)=3a-11b\\\\ =&gt;&amp;2=(4b-a)-(3a-11b)=15b-4a \\end{align*}\\] $\\therefore 2=-4\\times 172 + 15\\times 46$ 还是代数好用"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%A0%91": {
    "title": "1.树",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%A0%91",
    "body": "树 Tree 定义 树是由$n(n\\geqslant0)$个有限节点组成的具有层次关系的集合。 把它叫做“树”是因为它看起来像一棵倒挂的树 也就是说它是根在上，而叶在下的。 通用名词 节点（结点）：树的最小单元 节点的度：子树数量 树的度：度最大的那个节点的度 叶子（终端节点）：没有子树的节点 非终端节点（分支节点）：有子树的节点。除根节点以外的非终端节点称为内部节点 双亲，孩子，兄弟，祖先，子孙，堂兄弟：同层的都叫堂兄弟，其他不解释 层次：根为第一层，孩子层次=双亲层次+1 深度：树的最大层次 有序树和无序树：若将树中每个结点的各子树看成是从左到右有次序的，则为有序树，否则为无序树 空树：一个节点都没有的树 存储结构 双亲表示法 孩子表示法 孩子兄弟表示法（二叉树表示法） 如下： 原树为A，转换后的二叉树为B 在B中 B中节点的左子树代表A中源节点的子树 B中节点的右子树代表A中源节点的兄弟 //---树的二叉链表存储表示---// typedef struct CSNode{ ElemType data; struct CSNode *firstchild, *nextsibling; }CSNode, *CSTree; 遍历方法 没有中序遍历是因为节点的度不一致，树的度不一定最大为2 先序遍历： 访问根； 从左到右，访问每棵子树 后序遍历： 从左到右，访问每棵子树； 访问根。 二叉树 定义 度$\\leqslant 2$的有序树 存储表示 //---二叉树的顺序存储表示---// #define MAXTSIZE 100 typedef TElemType SqBiTree[MAXTSIZE]; SqBiTree bt; //---二叉树的二叉链表存储表示---// typedef struct BiTNode{ TElemType data; struct BiTNode *lchild, *rchild; }BiTNode, *BiTree; 名词 完美二叉树：除了叶子，每个节点度都为2，叶子都在同一层 国内叫“满二叉树” 完满二叉树：除了叶子，每个节点度都为2 完全二叉树：叶子层可以不满的完美二叉树，并且叶子向左靠拢 二叉排序树、二叉搜索树、二叉查找树：左子树任意节点值&lt;根节点值&lt;右子树任意节点值 二叉树的遍历 前序遍历 访问根 访问左子树 访问右子树 中序遍历 访问左子树 访问根 访问右子树 后序遍历 访问左子树 访问右子树 访问根 查找树的中序遍历是有序数列 给定中序+前/后序则可以确定二叉树结构 前提：元素不重复 但是前序+后序不行，因为无法区分左右子树 中序提供左右子树区分，前后序提供根节点 规则：待补充…… 线索二叉树 定义 遍历的前驱和后继的信息就叫线索 线索二叉树就是把线索存入每个节点里的二叉树 这样在遍历的时候空间复杂度就是$O(1)$了（因为可以不使用栈，遍历返回根节点需要递归） 教科书里为了省空间，就只在度小于2的节点存储 并且只在没有子树的一边存储线索 LTag==0 ? lchild=左孩子 : lchild=前驱 RTag==0 ? rchild=右孩子 : rchild=后继 存储表示 //---线索二叉树存储表示---// typedef struct BiThrNode{ TElemType data; struct BiThrNode *lchild, *rchild; int LTag, RTag; }BiThrNode, *BiThrTree; 度为2的节点在线索二叉树中： 线索二叉树 前序 中序 后序 找前驱 F T T 找后继 T T F 注意： 节点输出自身时对应遍历中“访问根”的步骤 只有中序线索二叉树是完善的 因为遍历不需要前驱，所以前序可以不用栈遍历 后序线索二叉树仍需栈来遍历（纯纯的124） 哈夫曼树 http://c.biancheng.net/view/3398.html 定义 当用n个结点（都做叶子结点且都有各自的权值）试图构建一棵树时 如果构建的这棵树的带权路径长度最小 称这棵树为“哈夫曼树”（“最优二叉树”，“赫夫曼树”）。 这颗树的带权路径长度为： $WPL = 7\\times1 + 5\\times2 + 2\\times3 +4\\times3$ 存储表示 //---哈夫曼树的存储表示---// typedef stuct{ int weight; int parent, lchild, rchild; }HTNode, *HuffmanTree; 名词 路径：一个结点到另一个结点之间的通路 路径长度：在一条路径中，每经过一个结点，路径长度都要加1 结点的权(Weight)：结点上的一个有意义的数值 结点的带权路径长度：根结点到该结点的路径长度$\\times$该结点的权 树的带权路径长度(WPL)：所有叶子结点的带权路径长度之和 构建 不对左右子树做规定，所以 对于相同的一组权值，哈夫曼树不唯一 对于给定的有各自权值的 n 个结点： 选出两个权值最小的结点组成一个新的二叉树，根结点权值为两权值的和 在原有的n个权值中排除最小的两个权值，同时将新二叉树根节点的权值加入到 n–2 个权值的行列中 重复1和2，直到所有结点构建成一棵二叉树 这里其实有个容易陷入的误区，就是 选了两个节点组成树了之后，下一次不一定选这棵树的根节点来组队 应该仍然选剩下权值里最小的两个 这样构建的哈夫曼树就不是图中看起来那样往一边倒的样子了 编解码 (无)前缀编码 要设计长度不等的编码 则必须使任一字符的编码都不是另一个字符的编码的前缀 编码 什么样的前缀码能使得电文总长最短？ 哈夫曼编码 将字符作为哈夫曼树的叶子结点，出现次数作为权值 构造哈夫曼树 结点的左分支标0，右分支标１。 将根到叶子的路径上的标号连接起来，就是该叶子代表的字符的编码． 构建完成后 则： $\\because\\forall x,y\\lbrace x,y\\in LeafNodes\\rbrace ,\\space P(x,y)=x不为y的子节点$ $\\therefore 前缀不重复$ 权值越大，离根节点越近，编码就越短 对于编解码来说，前后所用的哈夫曼树需要完全一致 森林 $m(m\\geqslant0)$个不相交的树组成的集合 森林和二叉树的转换 用二叉树表示法，先将所有树转换为二叉树 然后将每棵树的根节点看成兄弟 从第一棵树开始，每个根节点的右子树都是森林中的另一棵树 其实我感觉这种混沌的表示方法应该斜着看，这样兄弟节点就在一行上面了 森林的遍历（递归定义） 前序遍历 访问根 访问子树 访问剩余的树构成的森林 中序遍历 访问子树 访问根 访问剩余的树构成的森林 后序遍历 访问子树 访问剩余的树构成的森林 访问根"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%9B%BE": {
    "title": "2.图",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.%E5%9B%BE",
    "body": "图 Graph 数据结构图(Graph)详解 定义 图是由顶点集合(Vertex)及顶点间的关系集合E组成的一种数据结构 记为$G=(V, E)$ 通用名词   顶点：图的最小单元 权：边上的一个有意义的数值 网：带权的图 边：两顶点间的关系，无向图中记作$(x,y)$ 弧：有向图的边，记作$\\left&lt;x,y\\right&gt;$，x为弧尾，y为弧头   子图：设$G=(V, E)$和$G’=(V’, E’)$，若$V’\\subseteq V$且$E’\\subseteq E$，则称$G’$为$G$的子图 邻接点：有边$(x,y)$，则$x，y$互为邻接点，也称$x，y$相邻接；边$(x,y)$依附于$x，y$，也称边$(x,y)$与$x，y$相关联 度：和该顶点相关的边的数量 入度：以该顶点为弧头的弧的数量 出度：以该顶点为弧尾的弧的数量 路径：一个顶点到另一个顶点之间的通路（箭头方向要相同） 路径长度：一条路径中边的数量 简单路径：顶点不重复出现的路径 回路（环）：第一个顶点和最后一个顶点相同的路径 简单回路（简单环）：除了第一个顶点和最后一个顶点，路径中的其余点不重复出现的路径   有向图，无向图：有向图单向箭头，无向图双向箭头 完全图：任意两顶点间都有边的图 连通图：任意两顶点间都有路径的图 连通：两顶点间有路径，称该两顶点连通 连通分量：不是连通图的无向图中符合连通图的性质的子图 强连通图：任意两顶点间都有来回$(v_i\\leftrightarrow v_j)$路径的有向图 强连通分量：不是强连通图的有向图中符合强连通图的性质的子图   有向树：满足下列条件的有向图 有且仅有一个结点入度为0 除根外的结点入度为1 从根到任一节点只有一条有向通路 生成树：对连通图进行遍历，过程中所经过的边和顶点的组合构成的树 生成森林：非连通图的生成树的集合 稀疏图，稠密图：一个比较模糊的概念，稀疏图大概是$e&lt; nlog_{2}{n}$的图，就是边远少于点的图，反之就是稠密图 最小生成树 最小生成树可能不唯一 定义 在遍历连通网时，总权值最小的生成树 求最小生成树 原理 一棵生成树与对应的图有如下性质： 图的所有顶点都在生成树中 生成树的边的数量为n-1 所以由此可得 要构造一棵最小生成树 将图中的边按权值升序排列 按次序选出不成环且覆盖所有顶点的边的集合 选到n-1条边的时候结束（因为大于n-1的时候一定成环） 这里是无后效性的，贪就完事了 Prim是从顶点开始，而Kruskal是从边开始 所以才有稠密稀疏适用性不同的说法 Prim算法 稠密图适用 步骤 $A$为空集，选择任一顶点移到$A$中 找出边$\\left(v_i,v_j \\right)$满足 $v_i\\in A \\oplus v_j\\in A$ 权值最小 将该边连接的顶点加入A中 跳到1，直至A为全部顶点的集合，恰好可以找到N-1条边 这样遍历出来的树就是一棵最小生成树 Kruskal算法 稀疏图适用 步骤 $A$为空集 找出边$\\left(v_i,v_j \\right)$满足 $\\neg(v_i\\in A \\wedge v_j\\in A)$ 权值最小 将该边连接的顶点加入A中 跳到1，直至A为全部顶点的集合，恰好可以找到N-1条边 这样遍历出来的树就是一棵最小生成树 存储结构 存储稠密图时，使用邻接矩阵 存储稀疏图时，使用邻接表 邻接矩阵 定义 设$G(V,E)$是具有$n$个顶点的图，则$G$的邻接矩阵是具有如下性质的$n$阶方阵： \\[\\begin{align*} A[i][j]= \\left \\{ \\begin{array}{ll} 1 , &amp;若\\left&lt;v_i,v_j\\right&gt;或(v_i,v_j) \\in E\\\\ 0 ,\\quad &amp;反之 \\end{array} \\right. \\end{align*}\\] 说人话就是 建立一个$n\\times n$的矩阵 如果$v_i$和$v_j$有边（弧）的话 就在$[i,j]$的位置上标1，反之标0 如果是网 那么就标权值，反之标$\\infty$ （$\\infty$为编程中允许的，比任何权值都大的数） 无向图 无向图的邻接矩阵是个对称矩阵 有向图 存储表示 //---图的邻接矩阵存储表示---// #define MaxInt 32767//极大值 #define MVNum 100//最大顶点数 typedef char VerTexType;//数据类型 typedef int ArcType;//权值类型 typedef struct{ VerTexType vexs [MVNum] ;//顶点表 ArcType arcs[MVNum][MVNum] ;//邻接矩阵 int vexnum, arcnum;//图的点数和边数 }AMGraph; 优缺点 优点 便于判断两顶点是否有边 便于计算顶点的度 缺点 不便于增删顶点 不便于统计边的数目 空间复杂度高 邻接表 定义 邻接表反映的是顶点的出度邻接情况 逆邻接表反映了顶点的入度邻接情况 以下是邻接表的示例 将所有顶点存储到线性表中 为每个顶点配备一个单链表 在该单链表中存储该顶点关联边（弧）的信息 如图 以顶点$V_1$为例，它的单链表中有两个结点 存储的值分别是2和1 2,1分别是$V_3$,$V_2$顶点在线性表中的下标 两节点分别表示$\\left&lt;V1, V3\\right&gt;,\\left&lt;V1, V2\\right&gt;$两条弧。 节点构成 顶点节点 data：存一些没啥用的信息 first：指向链表第一个元素 弧节点 adjvex：弧头下标 nextarc：链表的下一个元素 info：一些信息（可能是权值） 存储表示 //---图的邻接表存储表示---// #define MVNum 100//最大顶点数 typedef struct ArcNode{//边 int adjvex;//该边所指向的顶点 struct ArcNode *nextarc;//指向下一条边 OtherInfo info;//信息（比如权重） }ArcNode; typedef struct VNode{//顶点 VerTexType data;//顶点信息 ArcNode *firstarc;//指向第一条边 }VNode, AdjList[MVNum];//AdjList表示邻接表类型 typedef struct{ AdjList vertices; int vexnum, arcnum;//图的顶点数和边数 }ALGraph; 优缺点 优点 便于增删顶点 便于统计边的数目 空间复杂度低 缺点 不便于判断两顶点是否有边 不便于计算顶点的度 十字链表 最好用来存储有向图 定义 邻接表和逆邻接表的结合 将所有顶点存储到线性表中 为每个顶点配备两个单链表 一个链表记录以当前顶点为弧头的弧 另一个链表记录以当前顶点为弧尾的弧 每条边有两个指向下一条关联边的指针（见下，节点构成） 可能会有个疑问，在这张图片中 十字链表各个节点到底是怎么指的这么乱的? 其实，该图中的节点是以 弧尾下标为行 弧头下标为列 进行排列的 所以，节点的指向先从线性表开始 该行的弧全是以该顶点为弧尾的弧 然后，再从线性表依次看 将firstin指向该顶点作为弧头对应的列的第一个弧节点 最后，竖着看，从上到下把弧节点连起来 该列的弧全是以该弧头为弧头的弧 这张图中的整个表就构建完了 其实在真实情况下它不一定给你按照从小到大，从左到右的顺序输入 这个时候就是先输入的先被连接 当一个弧节点被输入进来时 先将其接到对应弧尾的顶点节点的tlink链表的最末端 后将其接到对应弧头的顶点节点的hlink链表的最末端 节点就添加完成了 代码和逻辑不复杂 就是加弧的时候分别在两个顶点的尾链表和头链表push 但是画成图就很复杂 看起来就是错综复杂到处飞线的样子 结合了邻接矩阵和邻接表的优点 节点构成 顶点节点 data：存一些没啥用的信息 firstin：第一条以当前顶点为弧头的弧 firstout：第一条以当前顶点为弧尾的弧 弧节点 tailvex：弧尾下标 headvex：弧头下标 hlink：弧头相同的下一条弧 tlink：弧尾相同的下一条弧 info：一些信息（可能是权值） 这里写成”thht”而非”thth”是因为在画图理线的时候比较顺 存储表示 //---图的十字链表存储表示---// #define MAX_VERTEX_NUM 20 //图中顶点的最大数量 //弧结点 typedef struct ArcBox { int tailvex, headvex; //弧尾、弧头下标 struct ArcBox* hlink, * tlink; InfoType info; //存储弧相关信息的指针 }ArcBox; //顶点节点 typedef struct VexNode { VertexType data; //顶点的数据域 ArcBox* firstin, * firstout; }VexNode; //十字链表 typedef struct { VexNode xlist[MAX_VERTEX_NUM]; //存储顶点的顺序表 int vexnum, arcnum; //顶点数和弧数 }OLGraph; 邻接多重表 专门存储无向图的存储结构 因为在邻接表中存储无向图的时候 一条边被存储了两次 这样会存在很多的重复空间和操作 于是邻接多重表就诞生了 定义 将所有顶点存储到线性表中 为每个顶点配备一个单链表 在该单链表中存储该顶点关联边的信息 每条边有两个指向下一条关联边的指针（见下，节点构成） 邻接表存储无向图 邻接多重表存储无向图 和十字链表的理解是差不多的 也是加边的时候分别在两个相关顶点的链表push 节点构成 顶点节点 data：存一些没啥用的信息 firstedge：第一条与该顶点关联的边 弧节点 mark：待补充……（这个书上说的是访问标记，避免重复遍历用的） ivex,jvex：与该边有关的两顶点 ilink：下一个与ivex有关的边 jlink：下一个与jvex有关的边 info：存储一些信息，比如权值 存储表示 #define MAX_VERTEX_NUM 20 //图中顶点的最大数量 typedef enum { unvisited, visited }VisitIf; //边标志域 //表示链表中的各个结点 typedef struct EBox { VisitIf mark; //标志域 int ivex, jvex; //边两边顶点在顺序表中的位置下标 struct EBox* ilink, * jlink; //分别指向与ivex、jvex相关的下一个边结点 InfoType* info; //边的其它信息 }EBox; //存储图中的各个顶点 typedef struct VexBox { VertexType data; //顶点数据域 EBox* firstedge; //指向当前顶点对应的链表 }VexBox; //表示邻接多重表结构 typedef struct { VexBox adjmulist[MAX_VERTEX_NUM]; //存储图中顶点的顺序表 int vexnum, edgenum; //记录图中的顶点数量和边数量 }AMLGraph; 最短路径算法 最短路径算法 两顶点路径中总权值最小的一条路径称为最短路径"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86": {
    "title": "堆",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86",
    "body": "堆 优先队列 定义 父节点一定是其所有子孙节点的最值的一颗完全二叉树（该定义待补充，存疑） 存储结构 二叉堆 class Heap { public: int* heap; int size; Heap(int data[], int size) { this-&gt;size = 0; heap = new int[size]; for (int i = 0;i &lt; size;i++) this-&gt;push(data[i]); } void push(int x) { int index = size++; while (index &gt; 0) { int parentIndex = (index + 1) / 2 - 1; if (heap[parentIndex] &lt; x) break; heap[index] = heap[parentIndex]; index = parentIndex; } heap[index] = x; } int pop() { int result = heap[0];//获取最值 int x = heap[--size];//虽然没有对根节点直接赋值，但是下面等效为根节点值为x int index = 0; //和子节点比较大小，不断向下维护堆 while ((index + 1) * 2 &lt;= size) { int lIndex = (index + 1) * 2 - 1; int rIndex = (index + 1) * 2; int MinIndex = lIndex; if (rIndex &lt;= size &amp;&amp; heap[rIndex] &lt; heap[MinIndex]) MinIndex = rIndex; if (heap[MinIndex] &gt;= x) break; heap[index] = heap[MinIndex]; index = MinIndex; } heap[index] = x; return result; } }; D-堆 斐波那契堆 二项式堆 优先队列 该项编辑不完全 定义 可以插入新元素 可以快速取出所有元素的最值"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.0.%E5%BA%8F%E8%A8%80": {
    "title": "0.0.序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.0.%E5%BA%8F%E8%A8%80",
    "body": "Forge 最常用的Minecraft模组框架 Forge官方文档 安装环境 安装对应版本的JDK 在Forge官网下载MDK(Minecraft Development Kit) 解压后将文件夹在 可以使用Gradle的IDE 中打开，进行构建环境的自动配置 不同网络环境配置时间差距很大，请保证开启魔法并在良好的网络环境下配置 BUILD SUCCESSFULGradle构建完成 配置项目 游戏版本对应的Java版本 版本 JDK版本（最低要求） Lower Java 7 1.12.x(17w13a)~1.16.x Java 8 1.17.x(21w19a)~1.17.x Java 16 1.18.x(1.18-pre2)~Higher Java 17 项目结构 ├── LICENSE ├── README │ ├── gradle │   └── wrapper │   ├── gradle-wrapper.jar │   └── gradle-wrapper.properties ├── build.gradle ├── gradle.properties ├── gradlew ├── gradlew.bat ├── settings.gradle │  └── src ├── generated │   └── resources ├── main │   ├── java │   │   └── net │   │   └── example │   │   └── mod │   │   └── ExampleMod.java │   └── resources │   └── META-INF │   └── mods.toml └── test └── java └── net └── example └── mod └── ExampleModTest.java build.gradle mod.toml 你或许应该了解 Minecraft实际上已经成为了最大的游戏模组社区了 不只是模组，Minecraft社区也是最大的独立游戏玩家社区 模组是什么？ 模组其实是游戏的外置拓展 游戏模组（Game Mod）是指游戏玩家使用自己的创意和技能 通过修改游戏的原始数据、代码和资源来创建新的游戏体验和玩法 通常，游戏模组是游戏的非官方修改版本 玩家可以使用模组来增强游戏体验、改进游戏机制、添加新的关卡、角色、任务等等 游戏模组通常由游戏社区中的开发者、玩家和爱好者制作 并且它们可以在互联网上自由地分享和下载 有些游戏甚至专门为玩家开放了游戏开发工具包 以鼓励他们制作更多的游戏模组 从而促进游戏的创新和发展 如《魔兽争霸III》、《上古卷轴V：天际》等，都有大量的游戏模组 这些模组为游戏带来了更多的乐趣和持久性 回到Minecraft刚发布的时候 也就是2009年 Minecraft模组还没有像现在这样大范围流行 甚至没有什么话题度 因为那个时候整个社区只有几百个人。 但是随着两周以后的0.0.15a的发布 多人游戏被加入到游戏中 这鼓励玩家创造更多的UGC内容 但是那个时候Minecraft甚至没有客户端，大伙都是在网页上玩的 即使如此，也有一些向游戏中添加模组的方法，比如服务器插件 但是不像今天的bukkit或者sponge插件 这些插件只能实现一些基本功能 一年之后其实才有一个真正意义上的模组出现 到目前为止的问题就只有一个了，就是编写模组非常复杂 因为Minecraft毕竟是一个商业软件，它的代码都是混淆过的 就是说，它的代码被打乱到人肉眼难以看懂的地步了 你要保证两个模组互相兼容，你可能得逐条验证他们的代码有没有冲突 而且很多情况下模组并不能达到你想要的效果 所以你甚至要修改Minecraft的源代码 这个时候MCP，也就是Mod Coder Pack出现了 他对Minecraft的源码做了解析和反编译，并且做了标注，让人能读懂了 然后它的作者Searge后来进了mojang工作了，属于是被诏安了 再后面就是bukkit的出现取代了所有以前的服务器插件 然后bukkit整个团队又双叒进mojang了 你不用改Minecraft的源码就能添加很多功能进游戏了 然后modloader出现了 自此之后模组就相对而言比较容易兼容了 在这一时期，像是Industry工业和buildcraft被做出来了 但是远远称不上做得好 因为像这种大型的模组要实现的功能还是过于复杂了 还是要修改Minecraft的源码 你想要兼容，那大概率是不可能的 你得手动把修改的源码加到Minecraft的.java里面 这对普通玩家来说真的称不上友好 这个时候两个模组开发者建立了Forge 也就是我们今天要讲的，一个modloader的插件 后面开发人员将这个工作移交给了新的团队 这个团队开发了一个全新的modloader，一直沿用至今 其实除了forge还有其他的一些modloader 像是新兴的fabric，停更的liteloader，还有超级新的、现在还没什么人用的quilt 现在主流的modloader还是forge，绝大多数模组也都在forge上 我其实不太知道大家对于Minecraft到底是个怎样的认知 不过如果你玩过一些流行的大型模组，像是暮色森林或者是虚无世界、植物魔法 那么你其实就能知道我讲的这些是什么了 Forge因为牢大Lex现在分裂了，已经是夕阳框架了 Forge的时代或许要结束了 希望Cpw带领的NeoForge能够继往开来吧 在不久的将来"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.1.%E4%B9%A6%E7%AD%BE": {
    "title": "0.1.书签",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.1.%E4%B9%A6%E7%AD%BE",
    "body": "书签 你或许应该知道的… 每个分类中的项按照参考价值排序，由高到低 参考文档   MinecraftForge Documentation   Forge Community Wiki wiki.vg   ForgeGradle Documentation   我的世界开发者中文指南 ForgeJavaDocs-NG | Minecraft Forge Javadocs for 1.12.2 - 1.18.2.   Minecraft Wiki   网易MC开发指南 系统教程   正山小种   Boson   HoloJaneway   土球1.8.9FML MOD开发教程   Harbinger Sputnik | Sputnik - Next Gen. of Forge Tutor   Minecraft 1.12.2 Forge模组开发指引手册（以EOK为例） 森罗万象（资源包教程） 杂项   Mixin | 耗子的博客   Minecraft 睡前杂谈（二）—— 服务器与客户端：网络模型与数据同步 【Minecraft Forge】从零开始学习1.20.1模组开发 （一）：Forge的注册系统 自定义发光效果——浅谈着色器和帧缓冲在 Minecraft 的运用 [1.16.5]Determine the block that the player is looking at. 视频   修改钓鱼战利品表"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.2.%E5%BE%AE%E5%B0%8F%E7%9A%84%E5%BC%80%E5%A7%8B": {
    "title": "0.2.微小的开始",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/0.2.%E5%BE%AE%E5%B0%8F%E7%9A%84%E5%BC%80%E5%A7%8B",
    "body": "微小的开始 你需要干什么？ Forge本质上是破解了闭源程序的API 里面各种函数的功能都是靠猜出来的 而且不同的版本的详细实现也不一样 所以，这里只会讲一些通用的思路 具体到某个版本的实现，你需要去看书签 其实Forge文档写的不好，如果有不懂还是得善用Ctrl+B查看源码 如上，写模组是极度依赖经验的 除非你是天才 否则你不可能一下子就写出机械动力或者是应用能源这样的模组 所以，我建议你从微小开始 第一步 这里有一件很清楚的事情 就是你想写模组而不拥有这样的技术 你会在互联网上看到数不清的教程，一头雾水 首先，你需要冷静 你可以随便打开IDEA玩一玩，抄一抄网上的教程代码运行一下 然后先想清楚你要做什么 比如做一个腐肉烧皮革或者更多装备与工具 这样的模组比较简单，有很多现成的教程会手把手教你做 不要试图复刻现实中的专业器械，我的惨痛教训（bushi"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/1.%E6%96%B9%E5%9D%97": {
    "title": "1.方块",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/1.%E6%96%B9%E5%9D%97",
    "body": "方块 方块实体 数据同步 方块实体自带的数据同步是从服务端发向客户端的 在游戏时 getUpdatePacket：写数据 使用ClientboundBlockEntityDataPacket.create(this)从getUpdateTag获取数据 load：读数据 在区块加载时 getUpdateTag：写数据 handleUpdateTag：读数据 super.handleUpdateTag直接调用load处理 ClientboundBlockEntityDataPacket package net.minecraft.network.protocol.game; public class ClientboundBlockEntityDataPacket implements Packet&lt;ClientGamePacketListener&gt; { private final BlockPos pos; /** Used only for vanilla block entities */ private final BlockEntityType&lt;?&gt; type; @Nullable private final CompoundTag tag; //如果你有特殊需求可以直接使用这个方法 public static ClientboundBlockEntityDataPacket create(BlockEntity pBlockEntity, Function&lt;BlockEntity, CompoundTag&gt; pTagGetter) { return new ClientboundBlockEntityDataPacket(pBlockEntity.getBlockPos(), pBlockEntity.getType(), pTagGetter.apply(pBlockEntity)); } //这就是我们使用的方法 public static ClientboundBlockEntityDataPacket create(BlockEntity pBlockEntity) { return create(pBlockEntity, BlockEntity::getUpdateTag); } private ClientboundBlockEntityDataPacket(BlockPos pPos, BlockEntityType&lt;?&gt; pType, CompoundTag pTag) { this.pos = pPos; this.type = pType; this.tag = pTag.isEmpty() ? null : pTag; } public ClientboundBlockEntityDataPacket(FriendlyByteBuf pBuffer) { this.pos = pBuffer.readBlockPos(); this.type = pBuffer.readById(BuiltInRegistries.BLOCK_ENTITY_TYPE); this.tag = pBuffer.readNbt(); } //省略 //…… }"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/10.%E7%BA%BF%E7%A8%8B": {
    "title": "10.线程",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/10.%E7%BA%BF%E7%A8%8B",
    "body": "线程 event.enqueueWork"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/11.%E4%BA%8B%E4%BB%B6": {
    "title": "11.事件",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/11.%E4%BA%8B%E4%BB%B6",
    "body": "事件 参考事件系统 - Boson DeferredRegister不是Minecraft原版的，是Forge实现的 订阅与注册 订阅 使用@SubscribeEvent注解，写在方法上面进行订阅 @SubscribeEvent public void onEvent(Event event) { //something... } 注册 静态注册 @Mod.EventBusSubscriber() public class SomeClass { @SubscribeEvent public static void func(Event event) { //something... } } 会将SomeClass.func添加到监听列表 动态注册 MinecraftForge.EVENT_BUS.register(new EventHandler()); MinecraftForge.EVENT_BUS.register(SomeClass.class); 将EventHandler类（）中的所有@SubscribeEvent注解的非静态方法 或者是将class对象对应的类中的所有@SubscribeEvent注解的静态方法 添加到监听列表（大概是这样，待完善） 动态注册不是拿来把普通类中的方法添加到监听列表的 你依然需要一个专用的处理类 否则你传入的普通类对象会无法回收 如果必须要使用，在对象应该销毁时使用unregister取消注册"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/2.%E7%89%A9%E5%93%81": {
    "title": "2.物品",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/2.%E7%89%A9%E5%93%81",
    "body": "物品"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/3.%E5%AE%9E%E4%BD%93": {
    "title": "3.实体",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/3.%E5%AE%9E%E4%BD%93",
    "body": "实体"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/4.%E8%8D%AF%E6%B0%B4%E6%95%88%E6%9E%9C": {
    "title": "4.药水效果",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/4.%E8%8D%AF%E6%B0%B4%E6%95%88%E6%9E%9C",
    "body": "药水效果"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/5.%E4%B8%96%E7%95%8C%E7%94%9F%E6%88%90": {
    "title": "5.世界生成",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/5.%E4%B8%96%E7%95%8C%E7%94%9F%E6%88%90",
    "body": "世界生成"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/6.GUI": {
    "title": "6.gui",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/6.GUI",
    "body": "GUI Screen 界面 AbstractWidget 组件 Button 按钮 EditBox 输入框 字符串渲染流程： 字符串由value储存 渲染起始位置displayPos在setHighlightPos中由尾端减去getInnerWidth（元素宽度-边框宽度）得到 在renderWidget中通过this.font.plainSubstrByWidth截取从displayPos开始的getInnerWidth长度的字符串 检查字串不为空，pGuiGraphics.drawString渲染 如果value为空且未获焦点，绘制hint 如果有suggestion,会在文本末尾绘制 高亮区域=CursorPos到highlightPos的区域 杂项 Narratable 叙述功能 无障碍功能，用于屏幕阅读器 AbstactWidget继承了NarratableEntry 逻辑是按照Screen中的一个循环不断检测Delay 如果当前时间大于下一次播放时间，且大于禁止播放时间 就执行当前GUI的叙述检查 然后遍历Screen中的narratables 检查isActive中返回true的项（似乎是默认返回true，待检查） 如果有多项（一个GUI内有多个可叙述的组件），就叙述优先级为FOCUSED的项 并且输出Press Tab to navigate to next element的提示 可以用Tab和方向键选择组件 触发FocusNavigationEvent 如果使用Tab，则从Screen#this.children中顺序读取 如果使用方向键，则按照组件坐标从上到下，左侧优先读取"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/8.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF": {
    "title": "8.服务端与客户端",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/8.%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF",
    "body": "服务端与客户端 参考Sides - Forge Community Wiki LogicalSide：逻辑端 CLIENT：逻辑客户端 SERVER：逻辑服务端 Dist：硬件端 CLIENT：硬件客户端，同时包含逻辑客户端和逻辑服务端 DEDICATED_SERVER：硬件服务端，只有逻辑服务端 tips： level.isClientSide 是逻辑端 DistExecutor在指定的端上运行提供的Runnable 网络 同步/双端通信 方块实体同步 移步方块实体 自定义网络包 tips:Unknown custom packet identifier这个错误 是由于没有在handler的最后写context.setPacketHandled(true)导致的\\ 并且不要在enqueueWork中写context.setPacketHandled(true) 上面两种情况都会导致重新调用handler 由于handler在ClientPacketListener-&gt;handleCustomPayload第一行onCustomPayload调用 需要立刻获得handled布尔值进行判断 handleCustomPayload第一行onCustomPayload会post包处理事件到网络事件总线 然后返回handled或者false，为true则直接return，如果返回不为true，到下一行 第二行ensureRunningOnSameThread检测：如果不在同一线程，切换到主线程触发包处理（相当于递归handleCustomPayload）；如果在同一线程，就跳过 切换到主线程后网络事件总线应该是阻塞执行代码的（也有可能是之前enqueueWork执行完了，待求证…） 所以在enqueueWork中写context.setPacketHandled(true)不会报错，但仍会重新调用handler 杂项 PacketListener 描述了数据包的处理方式。针对每种可能的协议（例如PLAY，CLIENTBOUND；PLAY，SERVERBOUND等），该类都有不同的实现。"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/9.%E9%9F%B3%E6%95%88": {
    "title": "9.音效",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/9.%E9%9F%B3%E6%95%88",
    "body": "音效"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/99.%E6%9A%82%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%9C%B0%E6%96%B9%E6%94%BE%E7%9A%84%E4%B8%9C%E8%A5%BF": {
    "title": "99.暂时找不到地方放的东西",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/99.%E6%9A%82%E6%97%B6%E6%89%BE%E4%B8%8D%E5%88%B0%E5%9C%B0%E6%96%B9%E6%94%BE%E7%9A%84%E4%B8%9C%E8%A5%BF",
    "body": "暂时找不到地方放的东西 FriendlyBuf 这个代码定义了一个友好的 ByteBuf 类,它封装了一个普通的 ByteBuf,提供了许多便于序列化和反序列化 Java 对象的方法。 具体来说: 它提供了读写各种 Java 基本类型的方法,比如 readInt()/writeInt()。 它提供了读写字符串,NBT 数据,Enum等的方法。 它提供了读写集合、数组、地图等的方法。 它提供了读写 Java 对象的通用方法 readWithCodec()/writeWithCodec(),通过使用 Codec 来序列化。 它提供了读写 Minecraft 特定类型的方法,比如 BlockPos,ItemStack 等。 它还提供了一些工具方法,比如读写可选、可空对象,计算 VarInt 大小等。 总的来说,这个类通过提供专门的序列化方法,极大地简化了在网络传输中读写 Java 对象的过程。它抽象掉了底层的 ByteBuf 操作,开发者可以更加关注于应用层的数据表示和转换。 Inventory 对于玩家的主手 (MAIN_HAND) 或副手 (OFF_HAND): 这两个槽位是特殊的，它们不在玩家的主背包内，但它们确实有特定的槽位索引: 主手 (MAIN_HAND) 的槽位索引为 player.getInventory().selected，这是一个整数，表示玩家当前选择的热栏项。 副手 (OFF_HAND) 的槽位索引为 40。 EquipmentSlot 在 Minecraft 的源代码中，EquipmentSlot 是一个枚举，用于定义玩家或实体可以装备的各种物品槽，例如头盔、胸甲、腿甲、靴子、主手和副手。 方法 getFilterFlag() 的目的是为每个 EquipmentSlot 值返回一个唯一的整数。这个整数通常用于二进制位操作，如检查、设置或清除特定的槽位。 例如，您可能有一个整数，其每个二进制位代表一个特定的装备槽是否被禁用或启用。使用 getFilterFlag() 返回的值，您可以轻松地为特定的槽执行位操作。 考虑以下简单示例： Copy code int disabledSlots = 0; // 一个整数，其中每一位代表一个装备槽是否被禁用。 // 禁用头盔槽 disabledSlots |= (1 &lt;&lt; EquipmentSlot.HEAD.getFilterFlag()); // 检查胸甲槽是否被禁用 boolean isChestplateSlotDisabled = (disabledSlots &amp; (1 &lt;&lt; EquipmentSlot.CHEST.getFilterFlag())) != 0; 上述代码首先禁用了头盔槽，然后检查胸甲槽是否被禁用。 总之，getFilterFlag() 提供了一种方式来为每个装备槽获取一个唯一的整数，这在执行与槽相关的位操作时非常有用。"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/%E2%80%BB%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF": {
    "title": "※进阶技术",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Minecraft/Forge/%E2%80%BB%E8%BF%9B%E9%98%B6%E6%8A%80%E6%9C%AF",
    "body": "进阶技术 Parchment 反混淆 参考文档 Parchment Parchment Maven Parchment Github Repository Access Transformers 用于修改原版代码的访问修饰符 去掉build.gradle中accessTransformer前的注释符号 在META-INF文件夹下创建accesstransformer.cfg文件 获取MCP到SRG的映射 运行Gradle任务createMcpToSrg 在build/createMcpToSrg中找到对应映射名 IDEA中，在源代码中的字段右键菜单中点击Get SRG Name也可以得到 在accessTransformer.cfg填入AT指令 &lt;访问修饰符&gt; &lt;类的全称&gt; &lt;字段名&gt;(参数类型)&lt;返回类型&gt; 新的访问修饰符，如果想要去除final，则加-f标记，例如public-f 类的全名，例如net.minecraft.client.Minecraft 字段或方法的Searge名（方法需要添加相应的方法签名），如field_54654_a或func_4444_a()V 如下： # accesstransformer.cfg #Hook protected net.minecraft.world.entity.projectile.FishingHook f_37089_ # nibble protected net.minecraft.world.entity.projectile.FishingHook f_37094_ # hookedIn public net.minecraft.world.entity.projectile.FishingHook$FishHookState protected net.minecraft.world.entity.projectile.FishingHook f_37095_ # currentState protected net.minecraft.world.entity.projectile.FishingHook f_37103_ # life #Projectile protected net.minecraft.world.entity.projectile.Projectile f_150164_ # hasBeenShot protected net.minecraft.world.entity.projectile.Projectile f_37246_ # leftOwner protected net.minecraft.world.entity.projectile.Projectile m_37276_()Z # checkLeftOwner #Other public net.minecraft.client.gui.screens.Screen m_142437_()Ljava/util/List; #narratables Mixin 通过注入自己的代码，达到对MC原版内容的修改 Data Generator 用于自动生成Resources文件夹下的内容"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Qt/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Qt/@%E5%BA%8F%E8%A8%80",
    "body": "Qt Qt官网 一个代码库 有很多很多可以直接使用的功能 例如线程池，网络编程等等 支持很多语言，例如C++ 安装 最好下载在线安装器 因为在线库很乱，手动找很麻烦 去Qt官网下载开源版本在线安装器 使用命令行qt安装器路径.exe --mirror https://mirrors.aliyun.com/qt/ 选择需要的模块进行安装 minGW好像不能通过Qt直接安装吧大概 不说这个，minGW的版本必须与Qt的版本对应 否则会出现一些灾难性的错误 编译器可以选择minGW和MSVC 最好选MSVC Vscode 需要安装Qt tools和Qt Configure两个插件 MSVC，minGW均可使用Qt，看喜好选择 CMake配置 具体参阅Qt的官方文档 注意编译脚本（CMake）中Qt的路径和版本 需要用什么模块就引入什么模块 CMake也是一坨构室 ※疑难杂症 使用控制台进行输入输出 # CMake add_executable(${PROJECT_NAME} WIN32 # 注释掉这一行 # 原文： If you need a terminal for debug, please comment this statement ${srcs} ) set_target_properties(${PROJECT_NAME} PROPERTIES WIN32_EXECUTABLE OFF # 这一行改为OFF MACOSX_BUNDLE ON ) // c++ code QTextStream* qIn = new QTextStream(stdin); QString str; while (true) { str = qIn-&gt;readLine(); if (!str.isEmpty()) { // code here } } 使用Meta-Object Complier(MOC) 这个是当你声明了一个继承了QObject的子类 使用了自定义信号和槽（与之相伴的必须添加Q_OBJECT宏定义） 但是编译器并不知道这个类中有信号和槽 所以需要使用MOC来处理这个类 让编译器知道这个类中有信号和槽 声明在头文件中 // Func.h #pragma once #include \"../cpphead.h\" class InputThread : public QThread { Q_OBJECT//宏定义 public: InputThread(QObject* p = nullptr); void run() override; signals: void input(QString str); }; // Func.cpp #include \"head/cpphead.h\" InputThread::InputThread(QObject* p) : QThread(p) {} void InputThread::run() { QTextStream* qIn = new QTextStream(stdin); QString str; while (true) { str = qIn-&gt;readLine(); if (!str.isEmpty()) { emit input(str); } } } #include \"moc_Func.cpp\" //关键是这一行，moc_name.cpp 声明和定义都在源文件中 // Func.cpp #include \"head/cpphead.h\" class InputThread : public QThread { Q_OBJECT//宏定义 public: InputThread(QObject* p = nullptr) : QThread(p) {}; void run() override { QTextStream* qIn = new QTextStream(stdin); QString str; while (true) { str = qIn-&gt;readLine(); if (!str.isEmpty()) { emit input(str); } } } signals: void input(QString str); }; #include \"Func.moc\"//这一行 QTcpSocket多线程 QTcpSocket无法原生在其他线程调用 //关键是第三个参数，要写槽函数所在的对象，这样才会把信号从A线程发送到B线程，然后在B线程调用槽函数 QObject::connect(inputThread, &amp;InputThread::input, messageServer, [=](QString str) { for (QTcpSocket* tcpSocket : *messageServer-&gt;tcpSockets) { str = \"server:\" + str; messageServer-&gt;sendData(tcpSocket, str); } });"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Qt/Qt%20Installer%20FrameWork": {
    "title": "Qt installer framework",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%A1%86%E6%9E%B6/Qt/Qt%20Installer%20FrameWork",
    "body": "Qt Installer FrameWork Qt的一个组件，可以用来制作安装程序 官方手册 配置 文件目录结构 ├─output └─config config.xml └─packages └─com.yourname.component1 └─data yourprogram └─meta intallscript.qs package.xml └─com.yourname.component2 └─data yourprogram └─meta intallscript.qs package.xml config.xml Configuration File package.xml Package Directory installscript.qs function Component(){ // default constructor } Component.prototype.createOperations = function(){ // call default implementation to actually install README.txt! component.createOperations(); if (systemInfo.productType === \"windows\") { component.addOperation(\"CreateShortcut\", \"@TargetDir@/app.exe\",// target \"@DesktopDir@/app.lnk\",// link-path \"workingDirectory=@TargetDir@\",// working-dir \"iconPath=@TargetDir@/app.exe\",\"iconId=0\",// icon \"description=Start App\");// description } } 使用 binarycreator -c config/config.xml -p packages installer.exe"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/@%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8": {
    "title": "@复杂度表",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/@%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%A1%A8",
    "body": "复杂度表 排序方法 时间复杂度(平均) 时间复杂度(最坏) 时间复杂度(最好) 空间复杂度 稳定性 复杂性 直接插入排序 $O(n^{2})$ $O(n^{2})$ $O(n)$ $O(1)$ 稳定 简单 希尔排序 $O(n\\log_{2}{n})$ $O(n^{2})$ $O(n^{1.3})$ $O(1)$ 不稳定 较复杂 直接选择排序 $O(n^{2})$ $O(n^{2})$ $O(n^{2})$ $O(1)$ 不稳定 简单 堆排序 $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(1)$ 不稳定 较复杂 冒泡排序 $O(n^{2})$ $O(n^{2})$ $O(n)$ $O(1)$ 稳定 简单 快速排序 $O(n\\log_{2}{n})$ $O(n^{2})$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ 不稳定 较复杂 归并排序 $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n\\log_{2}{n})$ $O(n)$ 稳定 较复杂 基数排序 $O(d(n+r))$ $O(d(n+r))$ $O(d(n+r))$ $O(n+r)$ 稳定 较复杂"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F": {
    "title": "快速排序",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F",
    "body": "快速排序 强大，简洁，优美 查尔斯·霍尔惨遭隐姓埋名 原理 快速排序对冒泡排序进行了改进 其思想是： 通过一次排序将整个无序表分成相互独立的$A,B$两部分 $\\forall x \\lbrace x\\in A \\rbrace &lt; \\forall y \\lbrace y\\in B \\rbrace $ 然后继续用此法分别对$A,B$进行同样的操作 直到每一个小部分不可再分 所得的序列就成为了有序序列 其最核心的思想就是二分 单次过程图解 只是一种比较常用的分割方式 来源 整个过程中最重要的是实现分割操作 具体实现过程为： 设置两个指针 low(left) 和 high，分别指向无序表的表头和表尾，如下图所示： 先由 high 指针从右往左依次遍历，直到找到一个比 49 小的关键字，所以 high 指针走到 27 的地方停止。找到之后将该关键字同 low 指向的关键字进行互换： 然后指针 low 从左往右依次遍历，直到找到一个比 49 大的关键字为止，所以 low 指针走到 65 的地方停止。同样找到后同 high 指向的关键字进行互换： 指针 high 继续左移，到 13 所在的位置停止（13&lt;49），然后同 low 指向的关键字进行互换： 指针 low 继续右移，到 97 所在的位置停止（97&gt;49），然后同 high 指向的关键字互换位置： 指针 high 继续左移，此时两指针相遇，整个过程结束； 交换是为了储存keyValue，如果用一个变量储存keyValue，也可以不交换 代码实现 不同的人有不同的写法 但那个不同的部分都有一个相同的功能： *把小值放在keyValue左边，把大值放在keyValue右边* 其他部分都是大差不差的 C标准库代码 void Qsort(void* base, int left, int right, int size, int (*cmp)(const void* a, const void* b)) { /* left may be &lt; 0 because of the last - 1 */ assert(base != NULL &amp;&amp; size &gt;= 1 &amp;&amp; cmp != NULL); if (left &gt;= right) return; char* pleft = (char*)base + left * size; char* pkey = (char*)base + (left + (right - left) / 2) * size; swap(pleft, pkey, size); int last = left; char* plast = (char*)base + last * size; //这里的for做的操作是把keyValue放在第一个位置（第一个位置是暂存位） //把所有小于keyValue的值放在第一个位置的后面 //第一个值再与小值的最后一个交换 //这样所有小值就在keyValue左边，所有大值在keyValue右边 for (int i = left + 1; i &lt;= right; ++i) { char* pi = (char*)base + i * size; if (cmp(pi, pleft) &lt; 0) { ++last; plast = (char*)base + last * size; swap(pi, plast, size); } } swap(pleft, plast, size); //交换后*plast的值对应keyValue Qsort(base, left, last - 1, size, cmp); Qsort(base, last + 1, right, size, cmp); } 不使用交换 此处用width替代size void c_qsort(void* _arr, int left, int right, int size, int(*cmp)(const void* a, const void* b)) { //字节化_arr（使_arr内的数据进行字节对齐，方便操作） char* arr = (char*)_arr; if (left &lt; right) { int low = left; int high = right; char* keyValue = (char*)malloc(size); memcpy(keyValue, arr + low * size, size); //过程与图示相同，但直接覆盖元素 while (low &lt; high) { while (low &lt; high) { if (cmp(arr + high * size, keyValue) &lt; 0) { memcpy(arr + low * size, arr + high * size, size); break; } high--; } while (low &lt; high) { if (cmp(arr + low * size, keyValue) &gt; 0) { memcpy(arr + high * size, arr + low * size, size); break; } low++; } } //while完成之后将key指向的元素替换成keyValue memcpy(arr + low * size, keyValue, size); c_qsort(arr, low + 1, right, size, cmp); c_qsort(arr, left, low - 1, size, cmp); } } 省流版 其实vector有自带的sort template&lt;typename T&gt; void c_qsort(vector&lt;T&gt;&amp; arr, int left = -2, int right = -2) { left = left == -2 ? 0 : left; right = right == -2 ? arr.size() - 1 : right; bool flag = false; if (left &lt; right) { int lowKey = left; int highKey = right; while (lowKey &lt; highKey) { if (arr[lowKey] &gt; arr[highKey]) { swap(arr[lowKey], arr[highKey]); flag = !flag; continue; } flag ? lowKey++ : highKey--; } c_qsort(arr, lowKey + 1, right); c_qsort(arr, left, lowKey - 1); } }"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/@%E5%BA%8F%E8%A8%80",
    "body": "最短路 图 单源最短路： 一个点到其他点的最短路。 最短路径算法 描述 Dijkstra 该算法要求所有路径的权值为非负数 Bellman-Ford(SPFA) 该算法允许路径的权值为负数 多源（汇）最短路：任意两点间的最短路 最短路径算法 描述 Floyd-Warshall 允许非环路的路径权值为负数该算法不仅适用于稀疏图，在稠密图（路径数量多的图）中寻找最短路径的效率也很高。 Johnson 允许非环路的路径权值为负数该算法更适用于稀疏图（路径数量少的图）"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/Dijkstra": {
    "title": "Dijkstra",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95/%E6%9C%80%E7%9F%AD%E8%B7%AF/Dijkstra",
    "body": "Dijkstra 荷兰语 Dijkstra /ˈdaɪkstrə/ 将起始顶点的路径长度标记为0，其余顶点标记为$\\infty$ 找出未标记顶点中距离起始节点最小的顶点V 更新V的邻接点的路径距离 标记V 跳到1，直至无未标记顶点 原理 ？ 非常奇妙 我现在才想通 首先，它是动态规划 它看起来如此诡异，就是因为它对原始的dp做了一点点优化 它可以看做是dp广搜的优化版本（每轮取最短进行更新，优化了广搜对节点的重复遍历） 也可以看做是递归dp的 反向/不使用栈 版本（递归首先从汇点开始，x=该点，遍历x的邻接点，选出最短的那条） 每次选最小是因为： 首先不能乱选，因为要按层级来更新，不按层级更新到后面会有后效性（更新一个节点，后面大小关系全变了） 如果选最大，那么在权值为正的情况下，每轮都会选择刚刚更新过的那个节点（最大加完正值还是最大），直接一条路走到黑了，贪了，最后也会有后效性 选最小并不是单纯地逐层级更新，它是在确定最小后可能跳过了之前层级的较大点（因为较大点无论如何，到达下一层级之后的路程都不可能比该值小） 说Dijkstra是贪心，不如说它不得不贪。 我更倾向于像上面这样描述Dijkstra 就是一般dp的优化版 优化 堆优化（优先队列） 步骤1的实现方式为用堆获取最小值 代码实现 堆优化，邻接多重表 洛谷 P1119 灾后重建 - 提交记录 本页编辑不完全"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Batch/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Batch/@%E5%BA%8F%E8%A8%80",
    "body": "序言 用Windows不用Batch就相当于西方失去了耶路撒冷， 不用Batch注定只能过一个相对失败的人生 Batch，中文叫批处理 既有喜闻乐见的CMD(Command)，又有强大的PowerShell 作为和系统打交道的脚本语言， 大有可为，不可不为 先把坑占着"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Batch/%E9%93%BE%E6%8E%A5": {
    "title": "链接",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Batch/%E9%93%BE%E6%8E%A5",
    "body": "链接 Windows 中的硬链接、软链接、符号链接、快捷方式 定义 让一个文件可以拥有多个访问路径 这个是操作系统概念，不过暂时把它放在Batch里面 mklink可以创建硬链接/软链接/符号链接 种类 快捷方式 shortcut 不可用命令行创建，只能通过右键或者调用COM接口(IShellLink)创建 注意：快捷方式本质是lnk类型的文件，无法通过Path重定向 硬链接 hard link 软链接 junction point / soft link / reparse point 符号链接 区别 类型 链接到文件 链接到目录 跨越磁盘分区 指向不存在的目标 指向相对目录 删除 快捷方式shortcut 能 能 能 能 否 del file 硬链接hard link 能 否 否 否 否 del file 软链接junction point/softlink/reparsepoint 否 能 能 能 否 rd folder 符号链接 能 能 能 能 能 rd folder or del file"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E2%80%BB%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E": {
    "title": "※复杂声明",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E2%80%BB%E5%A4%8D%E6%9D%82%E5%A3%B0%E6%98%8E",
    "body": "复杂声明 声明只是一个约定俗成的规则 它不一定符合自然语言的逻辑 看不懂声明一般是遇到了函数指针和数组的声明 其实int* b这样写才是科学的，因为左边是类型，右边是变量名 但是复杂声明不太允许这样写，风格不太统一 所以就有了int *b这样的写法，它的意思是b=int* int *b、int *(b)、int (*b)都是指向 一个int类型的变量 的指针 函数指针声明 int (*func)() 这是格式，它的意思是func=int (*)() 即func是一个 返回类型为int的函数 的指针 第一个括号是为了把指针的声明塞进去 如果去掉括号，就变成了 函数声明 int func(); 是的，这个就是你非要把函数写在最下面然后识别不到，最后要在文件最上面写的东西 实际上函数也是一种变量类型，叫函数类型 数组声明 int a[] 它的意思是a=int []，即为a是一个int型数组 （提醒一下，所有[]里面都需要写数组大小） 指针的数组int *b[]： 等于int *(b[])、int *(b)[] 实为b=int*[] 指向数组的指针int (*b)[]： x为变量名，(*x)表示”x是指向该空间的指针” 也就是说除了int *b，只有把*和x直接括起来时才表示x是指针类型 区别在于*b和[]有没有用()隔开 一个括号层内只有*而没有[]的话，可以把这层的子括号去掉，如(*(*b[]))=(**b[]) 多维数组或者是指针套娃数组，反正无论是什么数组 层级都遵循从左到右从高到低 比如声明一个二维数组的.指针.数组 int (*b[])[][] 从右往左依次看就行，数组、二维数组、二维数组的指针数组这样 复合声明 让我们来看这位 int(*(*b[5]))() 从右到左，括号从外到内 右：函数 左：指针、双重指针的数组（注意不是指针数组指针） the 左 of 右：函数.的.双重指针.的.数组 可以简写为int (**b[])() 它把函数指针和数组的声明揉到一起了 它实际上是b=int()** [5]的意思 在复合声明中，函数指针声明永远在最底一层 也就是说b是一个数组，数组的元素是函数的双重指针 然后可以上上强度 如果要声明一个.二维数组的.指针数组.的指针，二维数组的第二层的元素是双重函数指针 那么应该这样写 int (**(*(*b)[5])[5][5])() 由内而外： 指针 *b 指针数组.的指针 *(*b)[5] 双重指针的.二维数组的.指针数组.的指针 **(*(*b)[5])[5][5] 双重函数指针.二维数组的.指针数组.的指针 (**(*(*b)[5])[5][5])() 由外而内： 此处的bx为子层级的指代 双重函数指针的二维数组，bx=(*(*b)[5]) (**bx[5][5])() .的指针，bx=(*b)[5] (**(*bx)[5][5])() 数组，bx=*b (**(*bx[5])[5][5])() .的指针 (**(*(*b)[5])[5][5])()"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E4%BD%8D%E5%9F%9F": {
    "title": "位域",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E4%BD%8D%E5%9F%9F",
    "body": "位域 Bit Field 定义 简单的说，位域就是小一点的普通变量 位域是一种特殊的存储方式，可以用小于sizeof(type)的大小进行存储 一些性质 位域按顺序从低位到高位排列 同一级下的位域遵循一定的规律进行压缩： 使用位域的主要目的是压缩存储，其大致规则为： 如果相邻位域字段的类型相同，且其位宽之和小于类型的sizeof大小，则后面的字段将紧邻前一个字段存储，直到不能容纳为止； 如果相邻位域字段的类型相同，但其位宽之和大于类型的sizeof大小，则后面的字段将从新的存储单元开始，其偏移量为其类型大小的整数倍； 如果相邻的位域字段的类型不同，则各编译器的具体实现有差异，VC6采取不压缩方式，Dev-C++采取压缩方式； 如果位域字段之间穿插着非位域字段，则不进行压缩； 整个结构体的总大小为最宽基本类型成员大小的整数倍。 Union下的位域 位域写在union下，就会受到union影响 union所有变量共用一个内存 所以所有的位域都用的是一块内存，就不存在顺序 统一从最低位开始存储 所以在union中直接使用位域和普通变量没有任何区别 如果要呈现“分块”的功能 就要在union中嵌套一个struct 普通的变量也是一样的 union Test{ struct{ int c : 8; int b : 8; int a : 16; //从低位到高位，倒着写 } int total; //这样total就是二进制位运算的a+b+c }"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E5%BC%95%E7%94%A8": {
    "title": "引用",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E5%9F%BA%E6%9C%AC/%E5%BC%95%E7%94%A8",
    "body": "引用 Reference 定义 引用是已定义的变量的别名 int a = 1; cout &lt;&lt; b; //输出1 左值与右值引用 左值：能对表达式取地址、或具名对象/变量。一般指表达式结束后依然存在的持久对象。 右值：不能对表达式取地址，或匿名对象。一般指表达式结束就不再存在的临时对象。 int &amp;&amp;a = 5&lt;——这就是右值引用的语法 void func(int &amp;a) { std::printf(\"%d \",a + 1); } void func(int &amp;&amp;a) { std::printf(\"%d \",a + 2); } void main() { int &amp;&amp;a = 1; func(a); func(1); } //func(a)为2，func(1)为3 //在重载上的应用 小东西 形如const int&amp;的参数类型会传递一个只读不改的引用参数"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/@%E5%BA%8F%E8%A8%80",
    "body": "现代C++ 我认为其实算竞学习的C++语法内容 其实没有真正摸到C++的更实用的内容 与Java，Python等一众新兴语言来讲的话 算竞使用的C++其实和C没有太大差别 而在实际工程中，现代化的C++是被频繁使用的 因为它能极高地提高我们开发的效率 更方便快捷 由此，简洁、强大、全面的C++迎来了它的新篇章： 现代C++ 其实C++11之后就是现代C++ 附上：现代C++教程"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8": {
    "title": "右值引用",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8",
    "body": "右值引用 本文是基于右值引用的应用 移动语义 Move Semantics 定义 传统 C++ 通过拷贝构造函数和赋值操作符为类对象设计了拷贝/复制的概念 但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式 否则就需要自己实现移动对象的接口 试想，搬家的时候是把家里的东西直接搬到新家去 而不是将所有东西复制一份（重买）再放到新家、再把原来的东西全部扔掉（销毁） 这是非常反人类的一件事情。 右值引用解决了拷贝复制带来的资源浪费问题 移动语义是在右值引用的基础上引入的 将一个对象的内容移动到另一个对象的操作 在拷贝语义中，会调用类的拷贝构造函数或者赋值构造函数 在移动语义中，会调用类的移动构造函数 这句话的意思是当赋值的变量或者类构造参数为左值时，会调用类的那个有左值参数的构造函数； 当其为右值时，会调用类的那个有右值引用参数的重载构造函数 class TA { int* a; TA() { } TA(const TA&amp; lvalue) { a = new int(*lvalue.a); }//拷贝语义 TA(const TA&amp;&amp; rvalue) { a = rvalue.a; }//移动语义 }; std::move 作用是把左值强转为右值 完美转发 Perfect Forwarding std::forward 保持参数的引用类型 template&lt;typename T&gt; void print(T&amp; t) { std::cout &lt;&lt; \"L\" &lt;&lt; std::endl; } template&lt;typename T&gt; void print(T&amp;&amp; t) { std::cout &lt;&lt; \"R\" &lt;&lt; std::endl; } template&lt;typename T&gt; void testForward(T&amp;&amp; v) { print(v);//始终调用左值重载的print print(std::forward&lt;T&gt;(v)); //保持实参的值类型 print(std::move(v)); //始终调用右值重载的print } int main(int argc, char* argv[]) { int x = 1; testForward(x); //实参为左值 testForward(std::move(x)); //实参为右值 }"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88": {
    "title": "智能指针",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C++/%E7%8E%B0%E4%BB%A3C++/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88",
    "body": "智能指针 Smart Pointer 与智能指针对应的是裸指针 智能指针的出现主要是为了解决内存泄漏的问题 可以自动释放内存 头文件为&lt;memory&gt; 注意： make_***的语法在C++14之后才引入 auto_ptr在C++11之后被舍弃 声明和初始化 #include &lt;memory&gt; void main(void) { //unique_ptr std::unique_ptr&lt;int&gt; p1; p1 = make_unique&lt;int&gt;(100);//100为构造函数的参数（初始化） std::unique_ptr&lt;int&gt; p2 {new int(100)}; std::unique_ptr&lt;int&gt; p3 {make_unique&lt;int&gt;(100)};//如上，但是效率更高，在11之前的版本更安全 //也可以使用new shared_ptr&lt;int&gt;(new int(100), delfunc)这种残疾模式来初始化 //或者shared_ptr&lt;int&gt; p(new int(100), delfunc); //shared_ptr std::shared_ptr&lt;int&gt; p4; p4 = make_shared&lt;int&gt;(100); std::shared_ptr&lt;int&gt; p5 {new int(100)}; std::shared_ptr&lt;int&gt; p6 {make_shared&lt;int&gt;(100)}; } 关于{}的初始化应用&lt;——其实这篇文章结构是一拖四，不过我暂时没有打算写这部分内容，所以将就用一下 unique_ptr 唯一指针 逻辑 不能复制，独占 删除器在编译时绑定，0额外开销 使用 unique_ptr&lt;int&gt; p2(p1.release()) unique_ptr&lt;int&gt; p2 = move(p1) 来转移控制权 shared_ptr 共享指针 逻辑 共享指针会记录指向同一个内存空间的共享指针个数 当最后一个共享指针被释放时，其指向的空间也会被释放 其实听起来蛮简单的，实现好像也蛮简单的，提示：自定义指针运算符，模板类，构造函数，析构函数 weak_ptr 逻辑 为了解决循环引用 不拥有资源，无法释放 若需访问资源要使用wp.lock()取出一个shared_ptr来访问 使用 声明和初始化 weak_ptr&lt;int&gt; p = make_shared&lt;int&gt;(100) 需要任意shared_ptr进行赋值 使用 wp.lock()返回裸指针的shared_ptr，如果计数为0，返回nullptr wp.use_count() expired()判断所观察资源是否已经释放 使用weak_ptr作为成员变量的类型即可解决循环引用\\ 小东西 auto_ptr 待写 boost 待写 shared_from_this 待写 成员函数 通用 ptr.get()会返回一个对应的裸指针 ptr.reset()会将ptr指向NULL，（并且原share计数减1） reset()可以有参数，参数为指向的新空间 ptr.release()解绑，返回裸指针（并且原share计数减1） ptr.swap(x)与x互换 shared_ptr str.use_count()返回引用计数 str.unique()检查是否独占 CSDN - C++ 智能指针 自定义删除行为 void close_file(FILE* fp){ if(fp == nullptr) return; fclose(fp); cout &lt;&lt; \"File closed.\" &lt;&lt; endl; } int main(){ FILE* fp = fopen(\"data.txt\",\"w\"); //unique_ptr unique_ptr&lt;FILE,decltype(&amp;close_file)&gt; ufp {fp,close_file};//模板类型第二个要写删除器类型，在第二个参数写上删除器 //shared_ptr shared_ptr&lt;FILE&gt; sfp {fp,close_file};//直接在第二个参数写上删除器 } 注意事项 不分配任何值时为nullptr 仅提供-&gt;，*，==运算符，没有+，-，++，–，[]等运算符 不要使用栈指针（因为智能指针使用delete释放空间，所以在构造时也需要new出来的空间） 空指针请用nullptr表示 nullptr是C++11之后的关键字，而NULL是宏定义为0，在类型推导时可能会出错 unique_ptr 把unique_ptr赋值为nullptr会释放原指针空间 shared_ptr 不要使用同一个原始指针进行默认构造shared_ptr&lt;int&gt; p2(num) 正确方法是shared_ptr&lt;int&gt; p2(p1) 会有一点点额外性能开销 循环引用 两个类互相拥有一个对方的shared_ptr成员变量 分别建立两个类的shared_ptr对象，把成员变量设为彼此 就会造成死锁 无法释放"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/HDL/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/HDL/@%E5%BA%8F%E8%A8%80",
    "body": "HDL Hardware Description Language 硬件描述语言 用代码代替画图 软件编程语言不能描述电路的时序性质 软件编程语言不能替代专用的硬件描述语言 建模：用HDL描述电路的功能 仿真：用电脑模拟电路，验证电路的功能，可以使用一些现实难以使用的调试方法 综合：把软件模型转化为硬件电路（相当于编译），类似于获得一张设计图的过程 VSCode的EDA环境安装 安装Python，安装VSCode插件TerosHDL pip install therosHDL，以及其他的py提示安装 下载GHDL，并添加Path 下载fpga-toolchain，并添加Path Windows要选择老一点的版本，名字带windows的 在VSCode的TerosHDL设置的Schematic viewer里选择(GHDL+Yosys) 这个是因为Netlist，也就是可视化图的问题 把fpga-toolchain里的ghdl.exe删掉 GNU_make Quartus Prime Lite 下载并根据默认设置安装 去Intel许可自助中心注册账号并点击右侧Enroll（登记），填写信息 等确认邮件收到后，点击左侧登入 登入后点击菜单条的注册评估或免费许可 选择Questa许可证，选择坐席数量，点击获取许可 新建计算机处选择NIC ID，选择Fixed，填写正在使用的网卡的mac地址 将收到邮件中的dat文件放入任意位置，然后将此文件添加到Path的系统变量LM_LICENSE_FILE 模拟时在-novopt参数前加上-suppress 12110，如果不加的话模拟不会出结果，怀疑是novopt带来的优化问题 Quartus联合Vscode开发教程"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/HDL/VHDL": {
    "title": "Vhdl",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/HDL/VHDL",
    "body": "VHDL Very High Speed Integrated Circuit Hardware Description Language 数据 数据对象 数据的前缀，用于约束数据的性质 CONSTANT：常量 VARIABLE：变量，只能在进程和子程序中使用，不存在延时，没有物理意义 SIGNAL：信号，不允许在进程和子程序中定义，是物理结构 数据对象 数据名:数据类型:=值 数据类型 预定义数据类型 在STD库的STANDARD包中： BOOLEAN BIT BIT_VECTOR：位矢量，位数组 CHARACTOR INTEGER NATURAL：自然数 POSITIVE：正整数 REAL：实数 TIME STRING 在IEEE库的STD_LOGIC_1164包中： STD_LOGIC：标准逻辑位 STD_LOGIC_VECTOR：标准逻辑矢量 自定义数据类型 枚举类型 TYPE name IS(state1,state2,state3,...) 整数类型：不写RANGE默认32位 TYPE name IS INTEGER RANGE value to value 子类型：原数据类型的一个子集 SUBTYPE name IS type RANGE value to value 数组类型 非限制性数组：当声明数据时再定义范围 TYPE name IS array(TYPE range&lt;&gt;) of TYPE 限制性数组：范围在类型声明时就已经定义 TYPE name IS array(value to value) of TYPE 结构 实体 Entity 模块的声明 ENTITY entityName IS GENERIC( name:type:=value; name:type:=value; ...); PORT( name:mode type; name:mode type; ...); END entiyName; 概念 源（Source）：信号的产生者 驱动（Drive）：是一个试图控制一个信号的值的实例或过程（赋值行为）。一个信号可以有一个或多个驱动，取决于它的类型和连接方式。 驱动器（Driver）：是一个为信号提供值的过程或端口。一个信号只能有一个驱动器，否则会出现错误。 解析函数（Resolution Function）：是一个用于确定多个驱动情况下信号值的函数。只有可解析的类型，如std_logic或std_logic_vector，才能使用解析函数。 PORT MODE的属性 IN: 输入，只读 OUT: 输出，只写 INOUT: 输入输出，双向端口，特别注意多重驱动的问题 BUFFER: 缓冲，不与其它实体的OUT、INOUT相连，但是可以被外部BUFFER驱动 PORT MODE 源方向 输出方向 IN（输入） 外 内 OUT（输出） 内 外 INOUT（双向） 内外 内外 BUFFER（缓冲） 内（特殊） 内外 结构体 Architecture 模块的定义 配置 Configuration 程序包和程序包体 Package 头文件 库 Library 命名空间"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/Event": {
    "title": "Event",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/Event",
    "body": "Event JS中的自定义事件"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/Web%20Worker": {
    "title": "Web worker",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/JavaScript/Web%20Worker",
    "body": "Web Worker JS的多线程 JS性能利器_Web Worker"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/@%E5%BA%8F%E8%A8%80",
    "body": "Python 非常哈人的语言，不推荐写大型工程 不推荐用python入门(虽然我就是用python入门的) python的语法和各种调用到处飞 我个人觉得只适合作为脚本使用"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/re": {
    "title": "Re",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Python/re",
    "body": "re import re re是个用来处理字符串的库 就图它的正则来的 函数 findall 返回string中所有与pattern匹配的全部字符串,返回形式为数组 pattern是正则表达式 re.findall(pattern, string, flags=0) 一些东西 flag 描述 re.I 忽略大小写 re.M 多行模式 re.S 点任意匹配模式 re.L 使预定义字符类 \\w \\W \\b \\B \\s \\S 取决于当前区域设定 re.U 使预定义字符类 \\w \\W \\b \\B \\s \\S 取决于unicode定义的字符属性 re.X 详细模式，正则表达式可以是多行的，忽略空白字符，可以加注释"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/@%E5%BA%8F%E8%A8%80",
    "body": "构建工具 是什么 你的项目的源代码写好以后 需要编译，运行，调试，发布 比如，你要写一个Hello World! // main.cpp #include &lt;iostream&gt; using namespace std; int main() { cout &lt;&lt; \"Hello World!\" &lt;&lt; endl; return 0; } 你可能会使用MSVC(cl.exe)或者是g++(g++.exe)来编译并运行 如果不想每次都手动输入命令 可以写一个批处理文件来自动化编译 比如 :: run.bat @echo off g++ main.cpp -o \"main.exe\" \"main.exe\" 上面这个就叫Makefile（广义的说法，因为有种固定的构建工具格式叫Makefile） 可以自动化编译你的源文件，按照你想要的方式运行 但是，如果你的项目很复杂 比如你把源文件放在不同的文件夹，或者是引入了第三方库，或者是使用了各种链接 你可能就需要一个专业的工具来管理你的项目的依赖，运行配置 比如Java的Maven和Gradle，C++的CMake和Meson 例如这个用于Qt的CMakeList.txt cmake_minimum_required(VERSION 3.5) # CMake install : https://cmake.org/download/ project(CUITExamClient LANGUAGES CXX) set(CMAKE_INCLUDE_CURRENT_DIR ON) # set(CMAKE_PREFIX_PATH \"$ENV{Qt}/6.4.2/mingw_64\") # Qt mingw Kit Dir set(CMAKE_PREFIX_PATH \"$ENV{Qt}/6.4.2/msvc2019_64\") # Qt msvc Kit Dir set(CMAKE_AUTOUIC ON) set(CMAKE_AUTOMOC ON) set(CMAKE_AUTORCC ON) set(CMAKE_CXX_STANDARD 17) set(CMAKE_CXX_STANDARD_REQUIRED ON) find_package(Qt6 COMPONENTS Network Widgets WebEngineWidgets REQUIRED) # Qt COMPONENTS aux_source_directory(./src srcs) qt_standard_project_setup() # Specify MSVC UTF-8 encoding # add_compile_options(\"$&lt;$&lt;C_COMPILER_ID:MSVC&gt;:/utf-8&gt;\") # add_compile_options(\"$&lt;$&lt;CXX_COMPILER_ID:MSVC&gt;:/utf-8&gt;\") add_subdirectory(CryptoPP) add_executable(${PROJECT_NAME} WIN32 # If you need a terminal for debug, please comment this statement ${srcs} ) target_link_libraries(${PROJECT_NAME} PRIVATE Qt6::Widgets Qt6::WebEngineWidgets Qt6::Network CryptoPP) # 用了什么额外的lib就要在这里写 set_target_properties(${PROJECT_NAME} PROPERTIES WIN32_EXECUTABLE ON MACOSX_BUNDLE ON ) target_include_directories(${PROJECT_NAME} PRIVATE ./CryptoPP/include) # target_link_libraries(${PROJECT_NAME} PRIVATE debug ${CMAKE_CURRENT_SOURCE_DIR}/CryptoPP/lib/Debug/cryptlib.lib optimized ${CMAKE_CURRENT_SOURCE_DIR}/CryptoPP/lib/Release/cryptlib.lib) Makefile Tool File composer composer.json Make makefile CMake CMakeLists.txt Maven pom.xml “约定优于配置” 基于约定优于配置(Convention over Configuration)是一种软件设计理念 主要应用于Java世界的Maven和Gradle等构建工具中 “约定”是指在工程结构、配置方式、默认行为等方面事先定义好一套标准、规则 基于约定的设计意味着,用户只要遵循这些预定的约定,就不需要做过多的配置 以Maven为例,它定义了一套标准的项目结构,例如: 源码都放在src/main/java 资源文件都放在src/main/resources 测试代码都放在src/test/java 并且它有默认的构建流程,例如执行mvn package时,会按照编译、测试、打包的顺序执行 用户只要按照这些约定组织项目的结构和文件,就可以直接使用Maven进行构建,不需要太多配置 相比之下,不基于约定的工具则需要用户大量的配置来定制行为,这被称为“配置优于约定” 基于约定的设计简化了使用,用户只要遵守约定就可以,减少了学习成本和配置工作 但也降低了灵活性,如果项目与约定不符,就需要更多配置来覆盖默认约定 所以综上,“基于约定”指利用预定义的标准结构和默认行为来减少配置 用户只要遵守这些预设的约定就可以直接使用"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/CMake": {
    "title": "Cmake",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/CMake",
    "body": "CMake 主要用于C/C++ 安装 在编译ASM文件时的注意事项 使用MSVC编译ASM时使用的是MASM编译器 然后ASM文件一定要放在该项目的根目录下 因为CMake在生成构建系统时不会自动创建父目录和源代码目录以外的文件夹 而且源代码目录是后生成的，还是找不到 如果非要分开写，那就会很残疾 可以像这样： foreach(libasm IN LISTS libasms) get_filename_component(libasm_basename ${libasm} NAME_WE) set(obj_file ${CMAKE_CURRENT_BINARY_DIR}/${libasm_basename}.obj) message(STATUS \"Compiling ${libasm_basename}.asm to ${obj_file}\") set_source_files_properties(${libasm} PROPERTIES COMPILE_FLAGS \"/Fo${obj_file} ${ASFLAGS64}\") endforeach() 就是用/Fo指定输出目录（否则ml64找不到输出目录就会报错） 但是我无论怎么指定${CMAKE_BUILD_TYPE}都无效，获取不到值，很奇怪，所以暂时不建议用这个"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle": {
    "title": "Gradle",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Gradle",
    "body": "Gradle 主要用于Java 安装 下载JDK和Gradle 解压并配置环境变量GRADLE_HOME=.../gradle/ 在Path中添加%GRADLE_HOME%\\bin 项目 目录结构 ├── gradle │   └── wrapper │   ├── gradle-wrapper.jar │   └── gradle-wrapper.properties ├── gradlew //Gradle Wrapper Linux ├── gradlew.bat //Gradle Wrapper Windows ├── settings.gradle //总项目配置（唯一） ├── build.gradle //构建配置 ├── gradle.properties //Gradle配置（全局） │ ├── app //子项目 │   ├── build.gradle //构建配置 │   ├── gradle.properties //Gradle配置（局部） │   └── ... │ ├── build //构建输出 │ └── src //源码"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Maven": {
    "title": "Maven",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/Maven",
    "body": "Maven 主要用于Java Apache下的一个项目自动构建工具 服务于Java平台的项目构建 安装 下载JDK和Maven 解压并配置环境变量MAVEN_HOME=.../apache-maven-x.x.x/ 添加环境变量%MAVEN_HOME%，并在Path中添加%MAVEN_HOME%/bin 项目 目录结构 a-maven-project ├── pom.xml │ ├── src │ ├── main │ │ ├── java //源码 │ │ └── resources //资源目录 │ └── test │ ├── java //测试源码 │ └── resources //测试资源目录 │ └── target //输出目录 ├── classes //编译输出目录 ├── test-classes //测试编译输出目录 └── ... POM Project Object Model pom.xml基本结构 &lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!-- 模型版本，固定为4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;!-- 项目组织唯一标识符 --&gt; &lt;!-- 由此生成配置时生成的路径，如com.companyname.project-group --&gt; &lt;!-- maven会将该项目打成的jar包放本地路径：/com/companyname/project-group --&gt; &lt;groupId&gt;com.companyname.project-group&lt;/groupId&gt; &lt;!-- 项目唯一标识符 --&gt; &lt;artifactId&gt;project&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/project&gt; 概念 基本 Maven工程：使用Maven进行管理的工程 坐标：由groupId，artifactId和version组成的项目唯一标识 约定(默认配置) Maven 提倡使用一个共同的标准目录结构 使用约定优于配置的原则 大家尽可能的遵守这样的目录结构 如下所示： 目录 目的 ${basedir} 存放pom.xml和所有的子目录 ${basedir}/src/main/java 项目的java源代码 ${basedir}/src/main/resources 项目的资源，比如说property文件，springmvc.xml ${basedir}/src/test/java 项目的测试类，比如说Junit代码 ${basedir}/src/test/resources 测试用的资源 ${basedir}/src/main/webapp/WEB-INF web应用文件目录，web项目的信息，比如存放web.xml、本地图片、jsp视图页面 ${basedir}/target 打包输出目录 ${basedir}/target/classes 编译输出目录 ${basedir}/target/test-classes 测试编译输出目录 Test.java Maven只会自动运行符合该命名规则的测试类 ~/.m2/repository Maven默认的本地仓库目录位置 插件 Maven只提供了最基本的依赖管理功能 所有的额外功能都是通过插件来实现的 生命周期 构建的不同阶段 Maven定义了项目构建跟发布时需要执行的所有步骤 并把它们抽象成不同的生命周期 每个生命周期包含多个阶段(Phase) 每个阶段会执行一组目标(Goal) 例如,编译和打包一个 Java 项目通常需要以下步骤: 清理目标文件 编译源代码 运行单元测试 打包成 JAR/WAR 文件 部署到服务器 Maven 用两个内置生命周期来描述这一过程: clean - 清理生命周期 pre-clean - 执行清理前需要完成的工作 clean - 清理上次构建生成的文件 post-clean - 执行清理后需要完成的工作 default - 构建生命周期 validate - 验证项目是否正确,所有需要的资源是否可用 compile - 编译项目的源代码 test - 使用合适的单元测试框架来测试编译的源代码 package - 把编译好的代码打包成可分发格式的文件,如 JAR/WAR verify - 对打包好的项目进行验证 install - 把打包的项目复制到本地仓库,可用于本地和远程依赖 deploy - 在构建环境中完成,把最终的工程包复制到远程仓库中与其他开发者和项目共享 pom.xml完整内容 &lt;tag /&gt;代指&lt;tag&gt;...&lt;/tag&gt; &lt;project xmlns = \"http://maven.apache.org/POM/4.0.0\" xmlns:xsi = \"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation = \"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;!--父项目的坐标。如果该项目某元素的值没有规定，那么继承父项目该值--&gt; &lt;parent&gt; &lt;artifactId /&gt;&lt;!-- 父项目唯一标识符 --&gt; &lt;groupId /&gt;&lt;!-- 父项目组织唯一标识符 --&gt; &lt;version /&gt;&lt;!-- 父项目版本 --&gt; &lt;!-- 父项目pom.xml文件相对路径，默认值是../pom.xml --&gt; &lt;!-- Maven首先在../pom.xml寻找父项目pom，其次relativePath，然后本地仓库，最后远程仓库 --&gt; &lt;relativePath&gt;...&lt;/relativePath&gt; &lt;/parent&gt; &lt;!--声明项目描述符遵循哪一个POM模型版本。基本固定为4.0.0 --&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;asia.banseon&lt;/groupId&gt;&lt;!--项目组织唯一标识符，项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt; &lt;artifactId&gt;banseon-maven2&lt;/artifactId&gt;&lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt; &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;name&gt;banseon-maven&lt;/name&gt;&lt;!--项目的名称, Maven产生的文档用 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;&lt;!--项目主页的URL, Maven产生的文档用 --&gt; &lt;description&gt;A maven project to study maven.&lt;/description&gt;&lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt; &lt;!--描述了这个项目构建环境中的前提条件。 --&gt; &lt;prerequisites&gt; &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt; &lt;maven /&gt; &lt;/prerequisites&gt; &lt;!--项目的问题管理系统(Bugzilla, Jira, Scarab,或任何你喜欢的问题管理系统)的名称和URL，本例为 jira --&gt; &lt;issueManagement&gt; &lt;!--问题管理系统（例如jira）的名字， --&gt; &lt;system&gt;jira&lt;/system&gt; &lt;!--该项目使用的问题管理系统的URL --&gt; &lt;url&gt;http://jira.baidu.com/banseon&lt;/url&gt; &lt;/issueManagement&gt; &lt;!--项目持续集成信息 --&gt; &lt;ciManagement&gt; &lt;!--持续集成系统的名字，例如continuum --&gt; &lt;system /&gt; &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt; &lt;url /&gt; &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt; &lt;notifiers&gt; &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt; &lt;notifier&gt; &lt;type /&gt;&lt;!--传送通知的途径 --&gt; &lt;sendOnError /&gt;&lt;!--发生错误时是否通知 --&gt; &lt;sendOnFailure /&gt;&lt;!--构建失败时是否通知 --&gt; &lt;sendOnSuccess /&gt;&lt;!--构建成功时是否通知 --&gt; &lt;sendOnWarning /&gt;&lt;!--发生警告时是否通知 --&gt; &lt;address /&gt;&lt;!--不赞成使用。通知发送到哪里 --&gt; &lt;configuration /&gt;&lt;!--扩展配置项 --&gt; &lt;/notifier&gt; &lt;/notifiers&gt; &lt;/ciManagement&gt; &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt; &lt;inceptionYear /&gt; &lt;!--项目相关邮件列表信息 --&gt; &lt;mailingLists&gt; &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt; &lt;mailingList&gt; &lt;!--邮件的名称 --&gt; &lt;name&gt;Demo&lt;/name&gt; &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;post&gt;banseon@126.com&lt;/post&gt; &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;subscribe&gt;banseon@126.com&lt;/subscribe&gt; &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt; &lt;unsubscribe&gt;banseon@126.com&lt;/unsubscribe&gt; &lt;!--你可以浏览邮件信息的URL --&gt; &lt;archive&gt;http:/hi.baidu.com/banseon/demo/dev/&lt;/archive&gt; &lt;/mailingList&gt; &lt;/mailingLists&gt; &lt;!--项目开发者列表 --&gt; &lt;developers&gt; &lt;!--某个项目开发者的信息 --&gt; &lt;developer&gt; &lt;id&gt;HELLO WORLD&lt;/id&gt;&lt;!--SCM里项目开发者的唯一标识符 --&gt; &lt;name&gt;banseon&lt;/name&gt;&lt;!--项目开发者的全名 --&gt; &lt;email&gt;banseon@126.com&lt;/email&gt;&lt;!--项目开发者的email --&gt; &lt;url /&gt;&lt;!--项目开发者的主页的URL --&gt; &lt;roles&gt;&lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt; &lt;role&gt;Project Manager&lt;/role&gt; &lt;role&gt;Architect&lt;/role&gt; &lt;/roles&gt; &lt;organization&gt;demo&lt;/organization&gt;&lt;!--项目开发者所属组织 --&gt; &lt;organizationUrl&gt;http://hi.baidu.com/banseon&lt;/organizationUrl&gt;&lt;!--项目开发者所属组织的URL --&gt; &lt;properties&gt;&lt;!--项目开发者属性，如即时消息如何处理等 --&gt; &lt;dept&gt;No&lt;/dept&gt; &lt;/properties&gt; &lt;timezone&gt;-5&lt;/timezone&gt;&lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt; &lt;/developer&gt; &lt;/developers&gt; &lt;!--项目的其他贡献者列表 --&gt; &lt;contributors&gt; &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt; &lt;contributor&gt; &lt;name /&gt; &lt;email /&gt; &lt;url /&gt; &lt;organization /&gt; &lt;organizationUrl /&gt; &lt;roles /&gt; &lt;timezone /&gt; &lt;properties /&gt; &lt;/contributor&gt; &lt;/contributors&gt; &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt; &lt;licenses&gt; &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt; &lt;license&gt; &lt;name&gt;Apache 2&lt;/name&gt;&lt;!--license用于法律上的名称 --&gt; &lt;url&gt;http://www.baidu.com/banseon/LICENSE-2.0.txt&lt;/url&gt;&lt;!--官方的license正文页面的URL --&gt; &lt;distribution&gt;repo&lt;/distribution&gt;&lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt; &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;&lt;!--关于license的补充信息 --&gt; &lt;/license&gt; &lt;/licenses&gt; &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt; &lt;scm&gt; &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt; &lt;connection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk) &lt;/connection&gt; &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt; &lt;developerConnection&gt; scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk &lt;/developerConnection&gt; &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt; &lt;tag /&gt; &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt; &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt; &lt;/scm&gt; &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt; &lt;organization&gt; &lt;name&gt;demo&lt;/name&gt;&lt;!--组织的全名 --&gt; &lt;url&gt;http://www.baidu.com/banseon&lt;/url&gt;&lt;!--组织主页的URL --&gt; &lt;/organization&gt; &lt;!--构建项目需要的信息 --&gt; &lt;build&gt; &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;sourceDirectory /&gt; &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt; &lt;scriptSourceDirectory /&gt; &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt; &lt;testSourceDirectory /&gt; &lt;!--被编译过的应用程序class文件存放的目录。 --&gt; &lt;outputDirectory /&gt; &lt;!--被编译过的测试class文件存放的目录。 --&gt; &lt;testOutputDirectory /&gt; &lt;!--使用来自该项目的一系列构建扩展 --&gt; &lt;extensions&gt; &lt;!--描述使用到的构建扩展。 --&gt; &lt;extension&gt; &lt;!--构建扩展的groupId --&gt; &lt;groupId /&gt; &lt;!--构建扩展的artifactId --&gt; &lt;artifactId /&gt; &lt;!--构建扩展的版本 --&gt; &lt;version /&gt; &lt;/extension&gt; &lt;/extensions&gt; &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt; &lt;defaultGoal /&gt; &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt; &lt;resources&gt; &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt; &lt;resource&gt; &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如${project.build.outputDirectory}）。举个例 子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt; &lt;targetPath /&gt; &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt; &lt;filtering /&gt; &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt; &lt;directory /&gt; &lt;!--包含的模式列表，例如**/*.xml. --&gt; &lt;includes /&gt; &lt;!--排除的模式列表，例如**/*.xml --&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt; &lt;testResources&gt; &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;!--构建产生的所有文件存放的目录 --&gt; &lt;directory /&gt; &lt;!--产生的构件的文件名，默认值是${artifactId}-${version}。 --&gt; &lt;finalName /&gt; &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt; &lt;filters /&gt; &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt; &lt;pluginManagement&gt; &lt;!--使用的插件列表 。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述插件所需要的信息。 --&gt; &lt;plugin&gt; &lt;!--插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt; &lt;extensions /&gt; &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt; &lt;executions&gt; &lt;!--execution元素包含了插件执行需要的信息 --&gt; &lt;execution&gt; &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt; &lt;id /&gt; &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt; &lt;phase /&gt; &lt;!--配置的执行目标 --&gt; &lt;goals /&gt; &lt;!--配置是否被传播到子POM --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;!--项目引入插件所需要的额外依赖 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--作为DOM对象的配置 --&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;!--使用的插件列表 --&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt; &lt;profiles&gt; &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt; &lt;profile&gt; &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt; &lt;id /&gt; &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt; &lt;activation&gt; &lt;!--profile默认是否激活的标志 --&gt; &lt;activeByDefault /&gt; &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt; &lt;jdk /&gt; &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt; &lt;os&gt; &lt;!--激活profile的操作系统的名字 --&gt; &lt;name&gt;Windows XP&lt;/name&gt; &lt;!--激活profile的操作系统所属家族(如 'windows') --&gt; &lt;family&gt;Windows&lt;/family&gt; &lt;!--激活profile的操作系统体系结构 --&gt; &lt;arch&gt;x86&lt;/arch&gt; &lt;!--激活profile的操作系统版本 --&gt; &lt;version&gt;5.1.2600&lt;/version&gt; &lt;/os&gt; &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过${名称}引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt; &lt;property&gt; &lt;!--激活profile的属性的名称 --&gt; &lt;name&gt;mavenVersion&lt;/name&gt; &lt;!--激活profile的属性的值 --&gt; &lt;value&gt;2.0.3&lt;/value&gt; &lt;/property&gt; &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt; &lt;file&gt; &lt;!--如果指定的文件存在，则激活profile。 --&gt; &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/exists&gt; &lt;!--如果指定的文件不存在，则激活profile。 --&gt; &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/ &lt;/missing&gt; &lt;/file&gt; &lt;/activation&gt; &lt;!--构建项目所需要的信息。参见build元素 --&gt; &lt;build&gt; &lt;defaultGoal /&gt; &lt;resources&gt; &lt;resource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;testResources&gt; &lt;testResource&gt; &lt;targetPath /&gt; &lt;filtering /&gt; &lt;directory /&gt; &lt;includes /&gt; &lt;excludes /&gt; &lt;/testResource&gt; &lt;/testResources&gt; &lt;directory /&gt; &lt;finalName /&gt; &lt;filters /&gt; &lt;pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/pluginManagement&gt; &lt;plugins&gt; &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt; &lt;plugin&gt; &lt;groupId /&gt; &lt;artifactId /&gt; &lt;version /&gt; &lt;extensions /&gt; &lt;executions&gt; &lt;execution&gt; &lt;id /&gt; &lt;phase /&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/execution&gt; &lt;/executions&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;goals /&gt; &lt;inherited /&gt; &lt;configuration /&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--参见repositories/repository元素 --&gt; &lt;repository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; &lt;releases&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;id /&gt; &lt;name /&gt; &lt;url /&gt; &lt;layout /&gt; &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports /&gt; &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行\"mvn site\"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt; &lt;reporting&gt; ...... &lt;/reporting&gt; &lt;!--参见dependencyManagement元素 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--参见distributionManagement元素 --&gt; &lt;distributionManagement&gt; ...... &lt;/distributionManagement&gt; &lt;!--参见properties元素 --&gt; &lt;properties /&gt; &lt;/profile&gt; &lt;/profiles&gt; &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt; &lt;modules /&gt; &lt;!--发现依赖和扩展的远程仓库列表。 --&gt; &lt;repositories&gt; &lt;!--包含需要连接到远程仓库的信息 --&gt; &lt;repository&gt; &lt;!--如何处理远程仓库里发布版本的下载 --&gt; &lt;releases&gt; &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt; &lt;enabled /&gt; &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt; &lt;updatePolicy /&gt; &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt; &lt;checksumPolicy /&gt; &lt;/releases&gt; &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt; &lt;snapshots&gt; &lt;enabled /&gt; &lt;updatePolicy /&gt; &lt;checksumPolicy /&gt; &lt;/snapshots&gt; &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt; &lt;id&gt;banseon-repository-proxy&lt;/id&gt; &lt;!--远程仓库名称 --&gt; &lt;name&gt;banseon-repository-proxy&lt;/name&gt; &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt; &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt; &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt; &lt;layout&gt;default&lt;/layout&gt; &lt;/repository&gt; &lt;/repositories&gt; &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt; &lt;pluginRepositories&gt; &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt; &lt;pluginRepository&gt; ...... &lt;/pluginRepository&gt; &lt;/pluginRepositories&gt; &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;!--依赖的group ID --&gt; &lt;groupId&gt;org.apache.maven&lt;/groupId&gt; &lt;!--依赖的artifact ID --&gt; &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt; &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt; &lt;type&gt;jar&lt;/type&gt; &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt; &lt;classifier&gt;&lt;/classifier&gt; &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如${java.home}。 --&gt; &lt;systemPath&gt;&lt;/systemPath&gt; &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt; &lt;reports&gt;&lt;/reports&gt; &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行\"mvn site\"，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt; &lt;reporting&gt; &lt;!--true，则，网站不包括默认的报表。这包括\"项目信息\"菜单中的报表。 --&gt; &lt;excludeDefaults /&gt; &lt;!--所有产生的报表存放到哪里。默认值是${project.build.directory}/site。 --&gt; &lt;outputDirectory /&gt; &lt;!--使用的报表插件和他们的配置。 --&gt; &lt;plugins&gt; &lt;!--plugin元素包含描述报表插件需要的信息 --&gt; &lt;plugin&gt; &lt;!--报表插件在仓库里的group ID --&gt; &lt;groupId /&gt; &lt;!--报表插件在仓库里的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--被使用的报表插件的版本（或版本范围） --&gt; &lt;version /&gt; &lt;!--任何配置是否被传播到子项目 --&gt; &lt;inherited /&gt; &lt;!--报表插件的配置 --&gt; &lt;configuration /&gt; &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt; &lt;reportSets&gt; &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt; &lt;reportSet&gt; &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt; &lt;id /&gt; &lt;!--产生报表集合时，被使用的报表的配置 --&gt; &lt;configuration /&gt; &lt;!--配置是否被继承到子POMs --&gt; &lt;inherited /&gt; &lt;!--这个集合里使用到哪些报表 --&gt; &lt;reports /&gt; &lt;/reportSet&gt; &lt;/reportSets&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/reporting&gt; &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;!--参见dependencies/dependency元素 --&gt; &lt;dependency&gt; ...... &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt; &lt;distributionManagement&gt; &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt; &lt;repository&gt; &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;banseon maven2&lt;/name&gt; &lt;url&gt;file://${basedir}/target/deploy&lt;/url&gt; &lt;layout /&gt; &lt;/repository&gt; &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt; &lt;snapshotRepository&gt; &lt;uniqueVersion /&gt; &lt;id&gt;banseon-maven2&lt;/id&gt; &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt; &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt; &lt;layout /&gt; &lt;/snapshotRepository&gt; &lt;!--部署项目的网站需要的信息 --&gt; &lt;site&gt; &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt; &lt;id&gt;banseon-site&lt;/id&gt; &lt;!--部署位置的名称 --&gt; &lt;name&gt;business api website&lt;/name&gt; &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt; &lt;url&gt; scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web &lt;/url&gt; &lt;/site&gt; &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt; &lt;downloadUrl /&gt; &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt; &lt;relocation&gt; &lt;!--构件新的group ID --&gt; &lt;groupId /&gt; &lt;!--构件新的artifact ID --&gt; &lt;artifactId /&gt; &lt;!--构件新的版本号 --&gt; &lt;version /&gt; &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt; &lt;message /&gt; &lt;/relocation&gt; &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt; &lt;status /&gt; &lt;/distributionManagement&gt; &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt; &lt;properties /&gt; &lt;/project&gt;"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0.%E5%AF%BC%E8%88%AA/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/0.%E5%AF%BC%E8%88%AA/@%E5%BA%8F%E8%A8%80",
    "body": "计算机基础 层级 内容 1 模拟电路、数字电路 2 计算机组成原理、计算机网络 3 编译原理、微机原理、计算机体系结构"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/@%E5%BA%8F%E8%A8%80": {
    "title": "@序言",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/@%E5%BA%8F%E8%A8%80",
    "body": "数字电路 数字电路主要讲述了基本的逻辑门、组合电路、时序电路、触发器等概念 以及如何利用这些元件设计一些简单的功能模块 是计算机组成原理的基础 不过还是有很多重合 我尽量分的清楚一点"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E5%8A%A0%E6%B3%95%E5%99%A8": {
    "title": "加法器",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E5%8A%A0%E6%B3%95%E5%99%A8",
    "body": "加法器 原理 半加器 全加器 8位加法器 概念 串行加法器 并行加法器 改良 超前进位加法器（CLA）"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97": {
    "title": "进制计算",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E8%BF%9B%E5%88%B6%E8%AE%A1%E7%AE%97",
    "body": "进制计算 二进制 普通计算机中，所有数据都是二进制的 在数字电路中，加法比较好实现 因为只需要一个异或门和一个与门(异或门负责加当前位，与门负责进位) 就可以实现一位的加法 但是减法就比较困难，没法直接计算 由此，负数就以补码形式表示 正数的补码是它本身，负数是它的按位取反加一 然后计算一个数和另一个数的相反数的和 Why？ 其实这是一个先发现二进制数的性质，再进行算法编写的过程 以一字节为例 0001 1001 = 25 0000 0100 = 4 取4的反码就是用255-4=251（255=1111 1111） 再加一就相当于256-4=252 相当于在一个256大小的空间中扣掉了4格 让256+25=277 然而计算过程中只有8位 所以第8位（128）满了之后要进的第九位（256）被直接丢掉了 最终在一字节内的结果是277-256=21 相当于用25格其中的4格填到251格凑成一个256 然后像俄罗斯方块一样，达到256的块就被消除了 最后剩下21，就是25-4的结果 $x-y=x+(z-y)-z$ 所以，当发现这个性质之后 有符号数的存储和计算就会在存储空间中对半砍 一半表示正数，一半表示负数 一般存储空间中最高位表示符号位，0为正（或0），1为负 （最高位此时代表的值为它的相反数，其他位代表值不变，意思指在取反后只看非最高位，相当于用（128-非最高位数）-128） 负数就用反码加一表示了（表示这个数的距离最大空间还缺了x个） 延伸来看，就不难理解为什么会出现255+1=0或者128+1=-127的情况了（最高进位损失了）"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E9%97%A8%E7%94%B5%E8%B7%AF": {
    "title": "门电路",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/1.%E6%95%B0%E5%AD%97%E7%94%B5%E8%B7%AF/%E9%97%A8%E7%94%B5%E8%B7%AF",
    "body": "门电路 基础门电路 与门 或门 非门 复合门电路 与非门 或非门 异或门 同或门"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/0.%E5%BC%95%E5%85%A5": {
    "title": "0.引入",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/0.%E5%BC%95%E5%85%A5",
    "body": "计算机组成原理"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B": {
    "title": "1.数据类型",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/2.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/1.%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B",
    "body": "数据类型 数值型数据 进位计数制 $(X_nX_{n-1}\\cdots X_0X_{-1}\\cdots X_{-m})_{r}$ $= X_nr^n+X_{n-1}r^{n-1}\\cdots X_{-m}r^{-m}$ 数码：可取的$x$，${X_i\\mid X_i\\in [0,r-1]，X_i\\in N}$ 基数：$r$，会产生进位的数值 权值：$r^i$，当前位的单位大小为$r^i$ 这个名字就是普通意思，可以当成生活中的计数方法 计数时伴随进位 形如$(10011010)_2$或者$(738)_{10}$ 表示n进制的某某数（10进制的738） 符号表示 概念 注意：这里是表示法，和我们学过的原码反码略有不同 最高位为符号位，符号位0正1负 原码表示法：除符号位以外为二进制绝对值 补码表示法：正数为原码（其本身），负数为补码(反码加1) 反码表示法：除符号位以外正数为原码，负数取反 移码表示法：$[X]_移=2^{n-1}+X$ 又称增码表示 n为总位数 就是将数沿数轴正向平移$2^{n-1}$ 可以类比为温度中的开尔文单位 符号位1正0负 0000 0000表示-128\\ 注意：IEEE754浮点数使用的移码是上述-1（127） 各表示法公式定义 \\[[X]_{原（定点小数）}= \\begin{array}{ll} \\begin{cases} X, &amp;\\quad\\qquad X\\in [0,1) \\hspace{5000px}\\\\ 1-X=1+|X|, &amp;\\quad\\qquad X\\in [-1,0) \\end{cases} \\end{array} \\\\ [X]_{原（定点整数）}= \\begin{array}{ll} \\begin{cases} X , &amp;\\qquad X\\in [0,2^n) \\hspace{5000px}\\\\ 2^n-X=2^n+|X|, &amp;\\qquad X\\in [-2^n,0) \\end{cases} \\end{array}\\] \\[[X]_{补（定点小数）}= \\begin{array}{ll} \\begin{cases} X , &amp;\\qquad\\quad X\\in [0,1) \\hspace{5000px}\\\\ 2+X=2-|X|, &amp;\\qquad\\quad X\\in [-1,0) \\end{cases} \\end{array} \\\\ [X]_{补（定点整数）}= \\begin{array}{ll} \\begin{cases} X , &amp;X\\in [0,2^n) \\hspace{5000px}\\\\ 2^{n+1}+X=2^{n+1}-|X| , &amp;X\\in [-2^n,0) \\end{cases} \\end{array}\\] \\[[X]_{反（定点小数）}= \\begin{array}{ll} \\begin{cases} X , &amp;\\qquad\\qquad X\\in [0,1) \\hspace{5000px}\\\\ (2-2^{-n})+X, &amp;\\qquad\\qquad X\\in [-1,0) \\end{cases} \\end{array} \\\\ [X]_{反（定点整数）}= \\begin{array}{ll} \\begin{cases} X , &amp;\\qquad\\qquad X\\in [0,2^n) \\hspace{5000px}\\\\ (2^{n+1}-1)+X , &amp;\\qquad\\qquad X\\in [-2^n,0) \\end{cases} \\end{array}\\] $[X]_补=(M + X) mod M $ M为你取的存储空间的最高位数+1的权值 也就是能够产生空间溢出的值 若想了解为什么用补码，请移步进制计算 小数表示 概念 范围：取值空间内的最小值到最大值（A到B），取值空间大小 分辨率：单位长度，最小可取的值 比例因子：用来将原始数据缩放到适合定点格式的一个因子（科学计数法的指数部分） 例如，如果原始数据是10.02，而定点格式是纯小数，那么可以用100作为比例因子，将其变成0.1002 定点数 小数点位置固定不变的数 有符号数最高位为符号位，符号位0正1负 定点整数：小数点隐含在最低位之后 定点小数：纯小数，小数点隐含在最高位（整数位）之后 浮点数 小数点位置不固定的数 数学形式 $N=\\pm R^E\\times M$ $R^E$为比例因子，$R$为基数，$E$为阶码，$M$为尾数 阶符和数符分别为阶码和尾数的符号位 实际形式 阶符 阶码 数符 数码 $E_0$ $E_1,E_2\\cdots,E_n$ $M_0$ $M_1,M_2\\cdots,M_n$ IEEE754浮点数 数符 阶码 尾数（除数符外） $S_0$ $[E]_移$ $[M_1,M_2\\cdots,M_n]_原$ 此处使用的偏移量为127 只移阶码 字符型数据 ASCII UTF GBK"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0.%E5%BC%95%E5%85%A5": {
    "title": "0.引入",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/0.%E5%BC%95%E5%85%A5",
    "body": "计算机网络"
  },"/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F": {
    "title": "电子邮件系统",
    "keywords": "",
    "url": "/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/3.%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6%E7%B3%BB%E7%BB%9F",
    "body": "电子邮件系统 Electronic Mail 协议 SMTP：Simple Mail Transfer Protocol，简单邮件传输协议 用于发送和中转发出的电子邮件，占用服务器的25/TCP端口。 POP3：Post Office Protocol 3，邮局协议版本3 用于将电子邮件存储到本地主机，占用服务器的110/TCP端口。 IMAP：Internet Message Access Protocol 4，Internet消息访问协议版本4 用于在本地主机上访问邮件，占用服务器的143/TCP端口。"
  },"/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F": {
    "title": "冒泡排序",
    "keywords": "",
    "url": "/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F",
    "body": "冒泡排序 C++ 实现 #include &lt;iostream&gt; int main() { int a[10], c, i, k, j, o; for (i= 0; i&lt; 10; i++) { std:: cin &gt;&gt; a[i]; } for (k= 0; k&lt; 10; k++) { for (j= 9; j&gt; k; j--) { if (a[j] &lt; a[j- 1]){ c= a[j- 1]; a[j- 1]= a[j]; a[j]= c; } } } for (o= 0; o&lt; 9; o++){ std:: cout &lt;&lt; a[o]&lt;&lt; ' '; } std:: cout&lt;&lt; a[9]; return 0; } 冒泡排序和选择性排序一样具有简单直观的特点 但数据量较大时，不如选择性排序效率高（”复杂度”为更专业的说法，更新前暂时不在这个笔记中谈)。"
  },"/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F": {
    "title": "插入排序",
    "keywords": "",
    "url": "/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F",
    "body": "插入排序 C++ 实现 #include &lt;iostream&gt; int main() { int a[100], i, j, key; for (i= 0; i&lt; 10; i++) { std:: cin&gt;&gt; a[i]; } for (i= 1; i&lt; 10;i++) { key= a[i]; j= i- 1; while (j&gt;= 0 &amp;&amp; a[j]&gt; key) { a[j+ 1]= a[j]; j--; } a[j+ 1]= key; //因为最后退出时j是下一回合的j } for (i= 0; i&lt; 9; i++){ std:: cout&lt;&lt; a[i]&lt;&lt; ' '; } std:: cout&lt;&lt; a[9]; } 插入排序与另外两种简单排序（选择性排序和冒泡排序）的区别在于使用了”while” 且体现了一个比较重要的编程思维，以下是我的一些浅薄思考。 $现在有七个字母。$ \\[A \\quad B \\quad C \\quad D \\quad E \\quad F \\quad G\\] $若想将G移动到A之前，常识的想法是先将G移动到A前，$ $随后剩下的字母会在物理世界的想象中中自然而然地向后排序。$ \\[\\lbrack\\quad\\rbrack \\quad G \\quad A \\quad B \\quad C \\quad D \\quad E \\quad F\\] $但在程序中只会出现：$ \\[\\lbrack\\quad\\rbrack \\quad G \\quad B \\quad C \\quad D \\quad E \\quad F \\qquad\\scriptsize(G替换了A)\\] $或是$ \\[G \\quad A \\quad B \\quad C \\quad D \\quad E \\quad F \\qquad\\scriptsize(G替换了\\lbrack\\quad\\rbrack)\\] $这里所体现的是数据本身并不具有物理性质，$ $换句话说，它不会排斥其他数据，可以说是完全的抽象概念。$ $但是在编程中，数据空间和数据又是不同的，$ $假若将储存空间想象成带有围栏的固定的物理空间，本身是合理的。$ $但却与抽象的数据不相同。这就好像是魔法，是一种在物理空间行使抽象操作的行为。$ $如此，我们发现，二者其实都是抽象的概念，都像是现实物理世界的某种缩影或某个特征，$ $这意味着什么呢？我们可以做更细致的讨论。$"
  },"/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F": {
    "title": "选择排序",
    "keywords": "",
    "url": "/DNote/old_jekyll/references/PhyMark/%E7%BC%96%E7%A8%8B/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F",
    "body": "选择排序 C++ 实现 #include &lt;iostream&gt; int main(){ int i, a[100], min, c, s, j; for (i= 1; i&lt; 10; i++) { //输入环节 std:: cin&gt;&gt; a[i]; } for (i= 0; i&lt; 9; i++) { //操作环节 min= a[i]; s= i; for (j= i+ 1; j&lt; 10; j++){ if(a[j]&lt; min){ min= a[j]; s= j; } } c= a[i]; a[i]= min; a[s]= c; } for (i= 0; i&lt; 9; i++){ //输出环节 std:: cout&lt;&lt; a[i]&lt;&lt; ' '; } std:: cout&lt;&lt; a[9]; return 0; } 选择性排序具有简单直观的特点 但循环边界的写法（i&lt; n or i&lt;= n）值得注意 在以后的算法学习中会经常遇到。"
  },"/DNote/old_jekyll/references/PhyMark/%E8%AF%BB%E4%B9%A6/%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89": {
    "title": "女性主义",
    "keywords": "",
    "url": "/DNote/old_jekyll/references/PhyMark/%E8%AF%BB%E4%B9%A6/%E5%A5%B3%E6%80%A7%E4%B8%BB%E4%B9%89",
    "body": "女性主义在公众讨论中的难题 难题在于：一方面，人们受到了不公正的待遇，从而要求平等， 而另一方面，两性之间的差异一直存在，且这种差异大多为中性乃至双面刃。 对于知识分子而言，这个矛盾极好解决，这是处于两个不同纬度的问题，受压迫的 人们就是受压迫了。但对公众的声音而言，他们往往不理解这种矛盾，总是以 “二者拥有各自的优缺点，各自拥有不同的社会福利”为证，诸如女性的退休年龄 比男性低。我有一个粗糙的想法，多去解释差异，将言说建立在差异的前提下，才能在压迫出现时使人理解矛盾。 另一困难 我想，女性主义言说的另一困难在于，只要讨论总是要区分出男性和女性，而女性主义却总是打着平权的旗号， 这一点对于公众讨论来说同样困难。 启发 以男性为多建立的哲学？ 摘引 历史上大部分开天辟地的哲学家都是男人，而且哲学通常是一个男性类型。女人既没有得到追求心灵生活的教育也没有这个时间。在现代社会，尤其是在过去200年，女人为文化作出了巨大的贡献，但是大多是对文学和艺术而不是哲学。她们在“伟大哲学家”的投票中缺席需要一个解释。 我感觉女人一般比男人要更不适合居于一个高度苦行的、冰冷的、分析的空间，而这正是哲学所在。女人从整体上——显然还是有例外——更接近于实践的、个人的事务。并不是她们天生缺乏哲学或更高的数学的天赋或才能，而是她们比男人更加不愿意将生命专注于一个已被自然和人类替代了的冰冷世界。 现在女人已经最终可以获得高等教育，我们期待着看看女人们可以在那些男人们划定为属于自己的——尤其是哲学——领域中能取得什么成就。然而目前，哲学风气并不繁荣，体系化的理性已经不再有它过去所拥有的威望和文化价值。我们洞悉世界的方式已经发生改变。哲学曾一度宣称提供一个严格的方法来探寻生命的意义，它也是宗教教条的珍贵替代品。但在现代社会，宗教已经在欧洲和北美的知识分子阶层失去了基础，知识分子们不再注意寻找答案的基本人类需求。哲学现在处于边缘。哲学已经在名誉和境界上大大缩水，它现在只是一个学术化的练习。 哲学世界最近的一个真正重要的运动是存在主义，主要代表是战后巴黎的让·保罗·萨特，阿尔波特·加缪和西蒙·德·波伏娃。自那以后有过语言哲学，但缺乏对最好的哲学进行特别深刻的洞察。后结构主义和后现代主义通过他们不可靠的相对主义，毁掉了哲学的概念。没有人在意哲学家，文化批评主义开始走向前沿。媒体和锋芒毕露的流行文化现在成为主宰，然而人们需要帮助来超越这一主宰并存活下来。 “女哲学家”这个词对我来说甚至并无意义。西蒙·德·波伏娃是一个思想家而不是一个哲学家。对我来说，哲学家远离日常关怀并操控术语和概念，就像一个网格或棋盘上的计数器。西蒙·德·波伏娃和艾茵·兰德，以及其他我所喜欢的，有着她们自己极具影响力的思维系统，因而她们也应属于伟大哲学家之列。 兰德的混合理论，社会观察以及评论完全是创造性的，尽管也能看到一些浪漫主义的苗头。她的体系是宽广和复杂的，非常值得并入哲学课程。 西蒙·德·波伏娃的大部头《第二性》显示了她的混合意识。它不符合严格的哲学定义，因为它是抽象思维和历史以及人类学－现实的合成物，类型问题可能是为什么这些女哲学家没有被列入伟大哲学家之列的原因。但是柏拉图也是一个戏剧性小说的作者——因而不考虑兰德是毫无理由的。 总是抱怨在男人的性别歧视下女人生活中的小斑点是令人厌烦的。现在缺乏重要的女哲学家不是因为女性缺乏才能，而是因为哲学本身的坍塌。像传统所作的那种哲学已经是一个僵死的类型。当今是互联网时代，我们在此被信息碎片淹没。电脑前的每个人都在着手寻求和捏造他的身份。网络模仿人类的神经，它已经根本改变了年轻人的脑子。无论好坏，网络是即时的。哲学属于一个消失了的时代，一个缓慢的、修辞形式的追问。 当今的哲学现在不过是古董的研究者。 ——作者为费城艺术大学（University of the Arts, Philadelphia）文科教授。以下为随文的附录（没有按照年代顺序，大抵是根据一定的重要性排序）："
  },"/DNote/old_jekyll/references/PhyMark/%E8%AF%BB%E4%B9%A6/%E6%84%9F%E7%9F%A5%20%E7%90%86%E7%9F%A5%20%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0": {
    "title": "感知 理知 自我认知》读书笔记",
    "keywords": "",
    "url": "/DNote/old_jekyll/references/PhyMark/%E8%AF%BB%E4%B9%A6/%E6%84%9F%E7%9F%A5%20%E7%90%86%E7%9F%A5%20%E8%87%AA%E6%88%91%E8%AE%A4%E7%9F%A5%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0",
    "body": "《感知 理知 自我认知》读书笔记，未整理完全，超乱 视觉的优先地位 我们看到了一个物体，我们就会说我们知道了一个物体，“看“与”是“联系在一起，但我们听到了一个物体的声音，不会说我们知道了一个物体，我们只是听到了某个物体的声音而已。术语上讲，这是由于视觉在认识论中具有优先地位，是因为一开始思考这些问题的人，更多是用“看”来表达，我们所谓”主观“，”客观“都是和”看“相关，这导致我们现在的思考，哲学都是从”看“出发。这也使我们从世界中抽象出的概念更多偏向“看”。”看“是从远处”看“，不是切身的去感受，或者说，这方面更少一些。“看”只能是“旁观”，但一个物体你从正面看，和从后面看并不一样，所以产生了视角问题，这个暂时不谈。而这样抽象出来的概念往往是图像，这个图像是某个物体的”本身“，也就是它的概念，它的逻辑存在方式。至于它有什么特点，我们暂且不谈。 触觉 触觉不同于视觉，触觉更多是切身感受事物，而用手摸却似乎也与“是”联系在一起，我们用手摸到了某种东西，也会说我们知道了一个东西。所以可以说，触觉既具有”看“的客观性，也具有“感知”的切身性。…(完成到一半就想到这个分类不对劲，之后再进行更新)。 上述推论并不成立 假设我们认为我们现在所用的只是概念是从视觉进路思考得出的，而这不过是多种进路的一种，那上述推论则不成立。因为要是在这个意义上，那么“视觉”和“概念”是一组相连的概念，而自然而然的“触觉”就和“是”并不联系。但这与实际不符，“用手摸”我们也会说我知道了这个东西，这说明“概念和本身”自身是较为独立的，而视觉只是更多的与此关联罢了。所以错误在于，“视觉”和“概念和本身”之间不是逻辑的因果关系，而是更为相近。我们只能说，我们的“逻辑”和“概念”与视觉更为相似，而这种最相似的程度似乎能称为“认识论上的优先地位”。 相似程度不能称为“认识论上的优先地位”，以及新的需要阅读得知的问题 但另外，我又想到，触觉相较视觉拥有更少的与“概念和本身”的相近性，为什么海德格尔还会讨厌使用“视觉”呢？少使用“视觉”是什么意思呢？所以我觉得，”认识论“并不是指的这一点，而是别的东西，所以上面这个相似程度不能称为”认识论上的优先地位“。那么认识论究竟囊括什么东西呢？“视觉”和“触觉”以及其和“逻辑和本身”相连的区别我们比较清晰的分辨了，但从视觉进路出发的认识论和从触觉出发的认识论有什么区别吗？我们只是知道了“认识论”不包括什么。我从字面上看，“认识论”指的是对“认识”的论理，讨论的是我们是怎么认识一个事物这样的问题，但这个问题仍不清楚。 认识论的内容在《感知 理知 自我认知》的前几章并没有说清楚。 ” 由于视觉是理知化的，理知和语言相连，所以视觉是在认识论上具有优先地位。 “ 上面这句话内容还不清晰具体内容，无法得知我们人类的选择空间在哪里。不知道我们为什么能够反对“传统认识论” 问题在于，我们人类的选择空间在哪里？如果我不明白什么是认识论，什么叫视觉在认识论中具有优先地位，和它 具有优先地位的方式，我无从得知这个问题。或许，这个选择空间和位置也需要我去阅读海德格尔的书。 问题1: 认识论是什么？ 问题2：我们的选择空间在哪里？ 两个问题相互联系，并不像表述一样切割。 第五章 闻知占我们“知”的大多数。古人往往以闻知和感知区分两个世界，现在也会区分两个世界-现实世界和科学世界，而科学世界的很多东西我们是感知不到，但这两种区分性质不同。而我们为什么能知道别人知道的就是自己知道的呢？理由有二，一：我们亲历过，二：我们相似。而如果哲学家提问：我们为什么知道别人知道的就是自己知道的呢？我们可以这样么想：小孩子似乎不太在意这个问题，可以知道这是哲学家在乎的事，哲学家为什么会在乎这个事呢？哲学家是怎么在乎这个事的呢？这是值得思考的问题。另外，感受不是甲虫，不能够像甲虫一样被对象化。而描述感受和表达感受是两个不同的文字游戏。 另外思考中的启发 逻辑的视觉性（缺细想） 学术要求我们学习前人，不管你有多天才，因为你要不学，没人知道你说的是什么。（缺细想） 用计算机写作和用纸笔写作会带来什么思考上的区别吗？（缺细想）"
  }}
