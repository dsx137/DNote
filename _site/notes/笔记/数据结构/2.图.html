<!DOCTYPE HTML>
<html lang="en" >
    <head><meta charset="UTF-8">
<meta content="text/html; charset=utf-8" http-equiv="Content-Type">
<meta name="referrer" content="no-referrer" /><title>2.图 · DNote</title><meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="description" content="Build Jekyll site with the GitBook style.
"><meta name="generator" content="Jekyll (using style of GitBook 3.2.3)"><meta name="author" content="dsx137"><link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/style.css">
<link rel="stylesheet" href="/DNote/old_jekyll/assets/modified_files/d-custom-style.css">
<link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-fontsettings/website.css">
<link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-search-pro/search.css">
<link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.css">

<link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/rouge/thankful_eyes.css">

<link rel="stylesheet" href="/DNote/old_jekyll/assets/gitbook/custom.css">

<link rel="stylesheet" href="/DNote/old_jekyll/assets/font_4eklf3gnlz2/iconfont.css">

<meta name="HandheldFriendly" content="true"/>
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<link rel="apple-touch-icon-precomposed" sizes="152x152" href="/DNote/old_jekyll/assets/gitbook/images/apple-touch-icon-precomposed-152.png">
<link rel="shortcut icon" href="/DNote/old_jekyll//assets/gitbook/images/favicon.ico" type="image/x-icon">





<script>
    MathJax = {
        "HTML-CSS": {
          availableFonts: ["TeX"],
        },
        tex2jax: {
            inlineMath: [['$','$'],["\\(","\\)"]]},
            displayMath: [ ['$$','$$'], ['\[','\]'] ],
        TeX: {
            extensions: ["AMSmath.js", "AMSsymbols.js", "color.js"],
            equationNumbers: {
                autoNumber: "AMS"
            }
        },
        svg: {
            fontCache: 'global'
        },
        showProcessingMessages: false,
        messageStyle: "none",
        imageFont: null,
        "AssistiveMML": { disabled: true }
        };
</script>
            <link rel="prev" href="/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%A0%91" />
        

        
            <link rel="next" href="/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86" />
        

    </head>
    <body>
        <canvas id="canvas" style="position:absolute;z-index: 999;pointer-events: none;" ></canvas>
        <div class="book"><div class="book-summary">
    <nav role="navigation">
        <div id="book-search-input" role="search">
            <input type="text" placeholder="Type to search" />
        </div>
        <div id="book-search-input-link" role="search">
            <a href="/DNote/old_jekyll/assets/search.html">Click to Search</a>
        </div>
        <ul class="summary" id="summary">
            <!-- 
            <li class="chapter" data-level="1.1" data-path="/DNote/old_jekyll">
            
                <a href="/DNote/old_jekyll/">
                    DNote
                </a>
            </li> -->

            
            <li data-level="1.1" data-path="/DNote/old_jekyll">
            
                <a class="chap" href="/DNote/old_jekyll/">
                    DNote
                </a>
            </li>

            
            <li data-level="1.1" data-path="/DNote/old_jekyll/References">
            
                <a class="chap" href="/DNote/old_jekyll/References">
                    References
                </a>
            </li>
            
            <hr></hr>
            <li class="divider"></li>
            
            <!-- 这是一个自定义的文件，功能是在gitbook左侧显示一个按文件分类的导航栏 by dsx137 -->
<script>
    var iconClassName = " iconfont";
    var shrinkIconClassName=" icon-shrink-s";
    var expandIconClassName=" icon-111111111";
    var summary = document.getElementById("summary");
    var pageURL = decodeURIComponent(window.location.href);

    // 通过增减classname后缀的方式来添加收缩的效果
    function toggleNav(){
        var ulElements = (Array)(this.parentNode.getElementsByTagName("ul"));
        for(var i in ulElements){
            var ul = ulElements[i][0];
            if(ul){
                var a = ul.parentNode.getElementsByTagName("a")[0];
                if(ul.className.includes("-active") || ul.className.includes("-active-animation")){
                ul.className=ul.className.replace("-active-animation","");
                ul.className=ul.className.replace("-active","");
                
                a.className=a.className.replace(expandIconClassName,"");
                a.className+=(shrinkIconClassName);
                }else{
                    ul.className+=("-active-animation");

                    a.className=a.className.replace(shrinkIconClassName,"");
                    a.className+=(expandIconClassName);
                }
            }
        }
    }

    function clearNavTree(){
        var summaryChildren = summary.getElementsByTagName("li");
        for(var i in summaryChildren){
            var li = summaryChildren[i];
            if(li.className.includes("remade-navigation")){
                summary.removeChild(li);
            }
        }
    }

    function sortTreeRaw(treeRaw){
        treeRaw.sort((a, b) => {
            var re = /(\D+|\d+)/g;
            var partsA = a.match(re);
            var partsB = b.match(re);
            //"abc123def456" -> ["abc", "123", "def", "456"]

            for (var i = 0; i < Math.min(partsA.length, partsB.length); i++) {
                var partA = partsA[i];
                var partB = partsB[i];

                if (partA !== partB) {
                    if (!isNaN(partA) && !isNaN(partB)) {
                        return parseInt(partA) - parseInt(partB);
                    } else {
                        return partA.localeCompare(partB);
                    }
                }
            }

            return partsA.length - partsB.length;
        });
    }

    /**
     * treeRaw是没处理的文件树信息，是一维数组，包含所有文件的路径
     * 使用这种方法获得
     * 
     *     treeRaw.push("_notes/@写作规范/@序言.md");
     * 
     *     treeRaw.push("_notes/@写作规范/Markdown.md");
     * 
     *     treeRaw.push("_notes/@写作规范/图片.md");
     * 
     *     treeRaw.push("_notes/@写作规范/文件开头的符号.md");
     * 
     *     treeRaw.push("_notes/@写作规范/零散.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/Git.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/Github API.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/Jekyll.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/LaTeX.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/Markdown.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/gost.md");
     * 
     *     treeRaw.push("_notes/笔记/其他/正则表达式.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/@导航/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/应用数学/概率论/0.引入.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/应用数学/概率论/1.随机事件及其概率.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/应用数学/概率论/2.随机变量及其分布.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/群.md");
     * 
     *     treeRaw.push("_notes/笔记/数学/纯粹数学/结构/数论/初等数论/最大公因数.md");
     * 
     *     treeRaw.push("_notes/笔记/数据结构/1.树.md");
     * 
     *     treeRaw.push("_notes/笔记/数据结构/2.图.md");
     * 
     *     treeRaw.push("_notes/笔记/数据结构/堆.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.0.序言.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.1.书签.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.2.微小的开始.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/1.方块.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/10.线程.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/11.事件.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/2.物品.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/3.实体.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/4.药水效果.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/5.世界生成.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/6.GUI.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/8.服务端与客户端.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/9.音效.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/99.暂时找不到地方放的东西.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Minecraft/Forge/※进阶技术.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Qt/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/框架/Qt/Qt Installer FrameWork.md");
     * 
     *     treeRaw.push("_notes/笔记/算法/排序/@复杂度表.md");
     * 
     *     treeRaw.push("_notes/笔记/算法/排序/快速排序.md");
     * 
     *     treeRaw.push("_notes/笔记/算法/最短路/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/算法/最短路/Dijkstra.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/Batch/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/Batch/链接.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/基本/※复杂声明.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/基本/位域.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/基本/引用.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/现代C++/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/现代C++/右值引用.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/C++/现代C++/智能指针.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/HDL/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/HDL/VHDL.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/JavaScript/Event.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/JavaScript/Web Worker.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/Python/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/Python/re.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/构建工具/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/构建工具/CMake.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/构建工具/Gradle.md");
     * 
     *     treeRaw.push("_notes/笔记/编程语言/构建工具/Maven.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/0.导航/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/1.数字电路/@序言.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/1.数字电路/加法器.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/1.数字电路/进制计算.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/1.数字电路/门电路.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/0.引入.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/1.数据类型.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/0.引入.md");
     * 
     *     treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/电子邮件系统.md");
     * 
     * 
     * 样式类名称
     * doctype = "my-docs";
     * 
     * hrefPrev是超链接URL的前缀
     * hrefPrev = "/DNote/notes/";
     * */
    function generateNavTree(doctype,treeRaw){

        //tree是一个二维数组，按'/'切分文件路径,删掉第一个元素（jekeyll collection的根目录）
        var tree = new Array();

        var hrefPrev = "/DNote/old_jekyll" + "/";

        var rootDir = "";

        sortTreeRaw(treeRaw);
        
        for (var i in treeRaw)
        {
            var fileNodeList = treeRaw[i].split("/"); 
            // fileNodeList.shift();.
            rootDir= fileNodeList.shift();
            tree.push(fileNodeList);
        }

        rootDir = rootDir.replace("_","");
        hrefPrev += rootDir + "/";
        
        buildTree(tree, hrefPrev, doctype);
    }

    function buildTree(tree, hrefPrev, doctype){
        //用Liquid捕获了gitbook的toc
        

        var toc = document.createElement("li");
        toc.innerHTML = "<ul><li><a href='#图'>> 图</a><ul><li><a href='#定义'>> 定义</a></li><li><a href='#通用名词'>> 通用名词</a><ul><li><a href='#最小生成树'>> 最小生成树</a></li></ul></li><li><a href='#存储结构'>> 存储结构</a><ul><li><a href='#邻接矩阵'>> 邻接矩阵</a></li><li><a href='#邻接表'>> 邻接表</a></li><li><a href='#十字链表'>> 十字链表</a></li><li><a href='#邻接多重表'>> 邻接多重表</a></li></ul></li><li><a href='#最短路径算法'>> 最短路径算法</a></li></ul></li></ul>";
        var tocChildren = toc.getElementsByTagName("a");
        
        //给toc添加样式
        for(var i in tocChildren){
            var a = tocChildren[i];
            a.className = "remade-toc";
        }

        //对文件进行遍历
        for (var i in tree)
        {
            var path = tree[i];
            //pathLevel用于记录当前遍历到的目录
            var pathLevel = hrefPrev+"";

            //遍历单文件目录节点
            for(var j in path)
            {
                var FolderNode=path[j];
                var haveSameParent = false;
                var haveSameNode = false;
                var parentNode = summary;
                var summaryChildren = summary.getElementsByTagName("li");

                //查找有无相同父目录，有的话把新节点添加到此目录下
                for(var k in summaryChildren)
                    if(summaryChildren[k].dataset!=null && summaryChildren[k].dataset.path==pathLevel)
                    {
                        haveSameParent = true;
                        parentNode = summaryChildren[k];
                        break;
                    }
                //这个FolderNode后面才加就是为了上面先查父目录
                pathLevel+=FolderNode+"/";

                //查找有无相同节点（这个是为了防止顶级目录重复）
                for(var k in summaryChildren)
                    if(summaryChildren[k].dataset!=null && summaryChildren[k].dataset.path==pathLevel)
                    {
                        haveSameNode=true;
                        break;
                    }
                
                var parentChildren = parentNode.children;
                
                if(!haveSameNode)
                {
                    //查找父目录li标签下的ul元素（ul元素下才是子目录存储的地方）
                    for(var i in parentChildren)
                        if(parentChildren[i].tagName=="UL")
                        {
                            parentNode = parentChildren[i];
                            break;
                        }
                    var node = document.createElement("li");
                    var hyperText = document.createElement("a");
                    var childList = document.createElement("ul");
                    
                    node.className = "remade-navigation";
                    node.dataset.path=pathLevel;
                    node.appendChild(hyperText);

                    //如果遍历到最深层（就是遍历到文件），那么在a标签创建超链接跳转，否则创建目录节点
                    if(FolderNode.includes(".md"))
                    {
                        FolderNode = FolderNode.substring(0, FolderNode.lastIndexOf("."));
                        pathLevel = pathLevel.substring(0, pathLevel.lastIndexOf("."));
                        hyperText.href = pathLevel;
                        if(pageURL.includes(pathLevel))
                            node.appendChild(toc);
                    }
                    else{
                        hyperText.className = doctype + iconClassName;

                        //判断文件是否对应当前URL，是的话展开目录
                        if(pageURL.includes(pathLevel)){
                            hyperText.className += expandIconClassName;
                            childList.className = "remade-ul-active";
                        }else{
                            hyperText.className += shrinkIconClassName;
                            childList.className = "remade-ul";
                        }
                        
                        node.appendChild(childList);
                    }
                    
                    hyperText.className+=" navigation-text-properties";
                    hyperText.innerHTML = FolderNode;
                    hyperText.onclick = toggleNav;
                    parentNode.appendChild(node);
                }
            }
        }
    }

        //弃用
    function generateNoteNavTree(){
       
        var doctype = "my-docs";
        var hrefPrev = "/DNote/old_jekyll/notes/";
        var treeRaw = new Array();
        var tree = new Array();

        //treeRaw是没处理的文件树信息，是一维数组，包含所有文件的路径
        //tree是一个二维数组，按'/'切分文件路径,删掉第一个元素（jekeyll collection的根目录）
        
            treeRaw.push("_notes/@写作规范/@序言.md");
        
            treeRaw.push("_notes/@写作规范/Markdown.md");
        
            treeRaw.push("_notes/@写作规范/图片.md");
        
            treeRaw.push("_notes/@写作规范/文件开头的符号.md");
        
            treeRaw.push("_notes/@写作规范/零散.md");
        
            treeRaw.push("_notes/笔记/其他/Git.md");
        
            treeRaw.push("_notes/笔记/其他/Github API.md");
        
            treeRaw.push("_notes/笔记/其他/Jekyll.md");
        
            treeRaw.push("_notes/笔记/其他/LaTeX.md");
        
            treeRaw.push("_notes/笔记/其他/Markdown.md");
        
            treeRaw.push("_notes/笔记/其他/gost.md");
        
            treeRaw.push("_notes/笔记/其他/正则表达式.md");
        
            treeRaw.push("_notes/笔记/数学/@导航/@序言.md");
        
            treeRaw.push("_notes/笔记/数学/应用数学/概率论/0.引入.md");
        
            treeRaw.push("_notes/笔记/数学/应用数学/概率论/1.随机事件及其概率.md");
        
            treeRaw.push("_notes/笔记/数学/应用数学/概率论/2.随机变量及其分布.md");
        
            treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/@序言.md");
        
            treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/群.md");
        
            treeRaw.push("_notes/笔记/数学/纯粹数学/结构/数论/初等数论/最大公因数.md");
        
            treeRaw.push("_notes/笔记/数据结构/1.树.md");
        
            treeRaw.push("_notes/笔记/数据结构/2.图.md");
        
            treeRaw.push("_notes/笔记/数据结构/堆.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.0.序言.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.1.书签.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.2.微小的开始.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/1.方块.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/10.线程.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/11.事件.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/2.物品.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/3.实体.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/4.药水效果.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/5.世界生成.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/6.GUI.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/8.服务端与客户端.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/9.音效.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/99.暂时找不到地方放的东西.md");
        
            treeRaw.push("_notes/笔记/框架/Minecraft/Forge/※进阶技术.md");
        
            treeRaw.push("_notes/笔记/框架/Qt/@序言.md");
        
            treeRaw.push("_notes/笔记/框架/Qt/Qt Installer FrameWork.md");
        
            treeRaw.push("_notes/笔记/算法/排序/@复杂度表.md");
        
            treeRaw.push("_notes/笔记/算法/排序/快速排序.md");
        
            treeRaw.push("_notes/笔记/算法/最短路/@序言.md");
        
            treeRaw.push("_notes/笔记/算法/最短路/Dijkstra.md");
        
            treeRaw.push("_notes/笔记/编程语言/Batch/@序言.md");
        
            treeRaw.push("_notes/笔记/编程语言/Batch/链接.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/基本/※复杂声明.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/基本/位域.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/基本/引用.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/现代C++/@序言.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/现代C++/右值引用.md");
        
            treeRaw.push("_notes/笔记/编程语言/C++/现代C++/智能指针.md");
        
            treeRaw.push("_notes/笔记/编程语言/HDL/@序言.md");
        
            treeRaw.push("_notes/笔记/编程语言/HDL/VHDL.md");
        
            treeRaw.push("_notes/笔记/编程语言/JavaScript/Event.md");
        
            treeRaw.push("_notes/笔记/编程语言/JavaScript/Web Worker.md");
        
            treeRaw.push("_notes/笔记/编程语言/Python/@序言.md");
        
            treeRaw.push("_notes/笔记/编程语言/Python/re.md");
        
            treeRaw.push("_notes/笔记/编程语言/构建工具/@序言.md");
        
            treeRaw.push("_notes/笔记/编程语言/构建工具/CMake.md");
        
            treeRaw.push("_notes/笔记/编程语言/构建工具/Gradle.md");
        
            treeRaw.push("_notes/笔记/编程语言/构建工具/Maven.md");
        
            treeRaw.push("_notes/笔记/计算机基础/0.导航/@序言.md");
        
            treeRaw.push("_notes/笔记/计算机基础/1.数字电路/@序言.md");
        
            treeRaw.push("_notes/笔记/计算机基础/1.数字电路/加法器.md");
        
            treeRaw.push("_notes/笔记/计算机基础/1.数字电路/进制计算.md");
        
            treeRaw.push("_notes/笔记/计算机基础/1.数字电路/门电路.md");
        
            treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/0.引入.md");
        
            treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/1.数据类型.md");
        
            treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/0.引入.md");
        
            treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/电子邮件系统.md");
        
        for (var i in treeRaw)
        {
            var fileNodeList = treeRaw[i].split("/"); 
            // fileNodeList.shift();
            fileNodeList.shift();
            tree.push(fileNodeList);
        }
        
        buildTree(tree, hrefPrev, doctype);
    }

    //弃用
    function generateReferenceNavTree(){
        
        var doctype = "reference-docs";
        var hrefPrev = "/DNote/old_jekyll/references/";
        var treeRaw = new Array();
        var tree = new Array();

        
            treeRaw.push("_references/PhyMark/编程/冒泡排序.md");
        
            treeRaw.push("_references/PhyMark/编程/插入排序.md");
        
            treeRaw.push("_references/PhyMark/编程/选择排序.md");
        
            treeRaw.push("_references/PhyMark/读书/女性主义.md");
        
            treeRaw.push("_references/PhyMark/读书/感知 理知 自我认知》读书笔记.md");
        
        for (var i in treeRaw)
        {
            var fileNodeList = treeRaw[i].split("/"); 
            // fileNodeList.shift();
            fileNodeList.shift();
            tree.push(fileNodeList);
        }
        
        buildTree(tree, hrefPrev, doctype);
    }
</script>

            <script>
                // var navSelectWorker = new SharedWorker("/DNote/old_jekyll/assets/modified_files/navSelectWorker.js");
                //监听.chapter <a>的点击事件
                // var chapters = document.querySelectorAll(".chapter");
                // for (var i = 0; i < chapters.length; i++) 
                //     chapters[i].addEventListener("click", function (e) {
                //         if(e.target.innerText== "DNote")
                //             navSelectWorker.port.postMessage("DNote");
                //         else if(e.target.innerText == "References")
                //             navSelectWorker.port.postMessage("References");
                //     });
                
                var pageURL = decodeURIComponent(window.location.href);

                if (pageURL.includes("/DNote/old_jekyll/notes/") || pageURL.split("/")[pageURL.split("/").length-1]==""){
                    var chapters = document.querySelectorAll(".chap");
                    for (var i = 0; i < chapters.length; i++) {
                        if(chapters[i].innerText == "DNote")
                            chapters[i].className += " my-docs";
                    }
                    var treeRaw = new Array();

                    
                        treeRaw.push("_notes/@写作规范/@序言.md");
                    
                        treeRaw.push("_notes/@写作规范/Markdown.md");
                    
                        treeRaw.push("_notes/@写作规范/图片.md");
                    
                        treeRaw.push("_notes/@写作规范/文件开头的符号.md");
                    
                        treeRaw.push("_notes/@写作规范/零散.md");
                    
                        treeRaw.push("_notes/笔记/其他/Git.md");
                    
                        treeRaw.push("_notes/笔记/其他/Github API.md");
                    
                        treeRaw.push("_notes/笔记/其他/Jekyll.md");
                    
                        treeRaw.push("_notes/笔记/其他/LaTeX.md");
                    
                        treeRaw.push("_notes/笔记/其他/Markdown.md");
                    
                        treeRaw.push("_notes/笔记/其他/gost.md");
                    
                        treeRaw.push("_notes/笔记/其他/正则表达式.md");
                    
                        treeRaw.push("_notes/笔记/数学/@导航/@序言.md");
                    
                        treeRaw.push("_notes/笔记/数学/应用数学/概率论/0.引入.md");
                    
                        treeRaw.push("_notes/笔记/数学/应用数学/概率论/1.随机事件及其概率.md");
                    
                        treeRaw.push("_notes/笔记/数学/应用数学/概率论/2.随机变量及其分布.md");
                    
                        treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/@序言.md");
                    
                        treeRaw.push("_notes/笔记/数学/纯粹数学/结构/代数/抽象代数/群.md");
                    
                        treeRaw.push("_notes/笔记/数学/纯粹数学/结构/数论/初等数论/最大公因数.md");
                    
                        treeRaw.push("_notes/笔记/数据结构/1.树.md");
                    
                        treeRaw.push("_notes/笔记/数据结构/2.图.md");
                    
                        treeRaw.push("_notes/笔记/数据结构/堆.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.0.序言.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.1.书签.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/0.2.微小的开始.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/1.方块.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/10.线程.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/11.事件.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/2.物品.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/3.实体.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/4.药水效果.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/5.世界生成.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/6.GUI.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/8.服务端与客户端.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/9.音效.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/99.暂时找不到地方放的东西.md");
                    
                        treeRaw.push("_notes/笔记/框架/Minecraft/Forge/※进阶技术.md");
                    
                        treeRaw.push("_notes/笔记/框架/Qt/@序言.md");
                    
                        treeRaw.push("_notes/笔记/框架/Qt/Qt Installer FrameWork.md");
                    
                        treeRaw.push("_notes/笔记/算法/排序/@复杂度表.md");
                    
                        treeRaw.push("_notes/笔记/算法/排序/快速排序.md");
                    
                        treeRaw.push("_notes/笔记/算法/最短路/@序言.md");
                    
                        treeRaw.push("_notes/笔记/算法/最短路/Dijkstra.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/Batch/@序言.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/Batch/链接.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/基本/※复杂声明.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/基本/位域.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/基本/引用.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/现代C++/@序言.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/现代C++/右值引用.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/C++/现代C++/智能指针.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/HDL/@序言.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/HDL/VHDL.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/JavaScript/Event.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/JavaScript/Web Worker.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/Python/@序言.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/Python/re.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/构建工具/@序言.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/构建工具/CMake.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/构建工具/Gradle.md");
                    
                        treeRaw.push("_notes/笔记/编程语言/构建工具/Maven.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/0.导航/@序言.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/1.数字电路/@序言.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/1.数字电路/加法器.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/1.数字电路/进制计算.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/1.数字电路/门电路.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/0.引入.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/2.计算机组成原理/1.数据类型.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/0.引入.md");
                    
                        treeRaw.push("_notes/笔记/计算机基础/3.计算机网络/电子邮件系统.md");
                    

                    generateNavTree("my-docs",treeRaw);
                }else if(pageURL.includes("/DNote/old_jekyll/references/") || pageURL.split("/")[pageURL.split("/").length-1]=="References"){
                    var chapters = document.querySelectorAll(".chap");
                    for (var i = 0; i < chapters.length; i++) {
                        if(chapters[i].innerText == "References")
                            chapters[i].className += " reference-docs";
                    }
                    var treeRaw = new Array();

                    
                        treeRaw.push("_references/PhyMark/编程/冒泡排序.md");
                    
                        treeRaw.push("_references/PhyMark/编程/插入排序.md");
                    
                        treeRaw.push("_references/PhyMark/编程/选择排序.md");
                    
                        treeRaw.push("_references/PhyMark/读书/女性主义.md");
                    
                        treeRaw.push("_references/PhyMark/读书/感知 理知 自我认知》读书笔记.md");
                    
                    
                    generateNavTree("reference-docs",treeRaw);
                }
                    // else{
                //     navSelectWorker.port.onmessage = function (e) {
                //     var nav = e.data;
                //     if(nav == "DNote")
                //         generateNoteNavTree();
                //     else if(nav == "References")
                //         generateReferenceNavTree();
                // };
            </script>

        </ul>
    </nav>
    
    <footer style="
        left: 0;
        background: #141c2e;
        display: flex;
        justify-content: center;
        bottom: 0;
        width: 100%;
        color: #ffff;">made by 
        <a href="https://sighingnow.github.io/jekyll-gitbook" style="color: #41515c;">&ensp;jekyll-gitbook </a>
    </footer>
</div>
<div class="book-body">
                <div class="book-header" role="navigation">
                    <!-- Title -->
                    <h1>
                        <i class="fa fa-circle-o-notch fa-spin"></i>
                        
                            <a href="" >2.图</a>
                        
                    </h1>
                </div>

                <div class="body-inner"><div class="page-wrapper" tabindex="-1" role="main">
    
    
    
    
    <div class="page-inner">
        <div id="book-search-results">
            <div class="search-noresults">
                <section class="normal markdown-section">
                    <!-- 
                        <h1 id="/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.图">2.图</h1>
                     -->
                    <h1 id="图">图</h1>

<blockquote>
  <p><strong>Graph</strong></p>
</blockquote>

<p><a href="http://data.biancheng.net/graph/">数据结构图(Graph)详解</a></p>

<h2 id="定义">定义</h2>

<blockquote>
  <p>图是由顶点集合(Vertex)及顶点间的关系集合E组成的一种数据结构<br />
记为$G=(V, E)$</p>
</blockquote>

<hr />

<h2 id="通用名词">通用名词</h2>

<ul>
  <li> 
    <ul>
      <li><code class="language-plaintext highlighter-rouge">顶点</code>：图的最小单元</li>
      <li><code class="language-plaintext highlighter-rouge">权</code>：<strong>边</strong>上的一个有意义的数值</li>
      <li><code class="language-plaintext highlighter-rouge">网</code>：带权的图</li>
      <li><code class="language-plaintext highlighter-rouge">边</code>：两顶点间的关系，无向图中记作$(x,y)$</li>
      <li><code class="language-plaintext highlighter-rouge">弧</code>：有向图的边，记作$\left&lt;x,y\right&gt;$，<strong>x为弧尾</strong>，<strong>y为弧头</strong></li>
    </ul>
  </li>
  <li> 
    <ul>
      <li><code class="language-plaintext highlighter-rouge">子图</code>：设$G=(V, E)$和$G’=(V’, E’)$，若$V’\subseteq V$且$E’\subseteq E$，则称$G’$为$G$的子图</li>
      <li><code class="language-plaintext highlighter-rouge">邻接点</code>：有边$(x,y)$，则$x，y$互为邻接点，也称$x，y$相邻接；边$(x,y)$依附于$x，y$，也称边$(x,y)$与$x，y$相关联</li>
      <li><code class="language-plaintext highlighter-rouge">度</code>：和该顶点相关的边的数量
        <ul>
          <li><code class="language-plaintext highlighter-rouge">入度</code>：以该顶点为弧头的弧的数量</li>
          <li><code class="language-plaintext highlighter-rouge">出度</code>：以该顶点为弧尾的弧的数量</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">路径</code>：一个顶点到另一个顶点之间的通路（箭头方向要相同）
        <ul>
          <li><code class="language-plaintext highlighter-rouge">路径长度</code>：一条路径中边的数量</li>
          <li><code class="language-plaintext highlighter-rouge">简单路径</code>：顶点不重复出现的路径</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">回路（环）</code>：第一个顶点和最后一个顶点相同的路径
        <ul>
          <li><code class="language-plaintext highlighter-rouge">简单回路（简单环）</code>：除了第一个顶点和最后一个顶点，路径中的其余点不重复出现的路径</li>
        </ul>
      </li>
    </ul>
  </li>
  <li> 
    <ul>
      <li><code class="language-plaintext highlighter-rouge">有向图，无向图</code>：有向图单向箭头，无向图双向箭头</li>
      <li><code class="language-plaintext highlighter-rouge">完全图</code>：任意两顶点间都有边的图</li>
      <li><code class="language-plaintext highlighter-rouge">连通图</code>：任意两顶点间都有路径的图
        <ul>
          <li><code class="language-plaintext highlighter-rouge">连通</code>：两顶点间有路径，称该两顶点连通</li>
          <li><code class="language-plaintext highlighter-rouge">连通分量</code>：不是连通图的无向图中符合连通图的性质的子图</li>
          <li><code class="language-plaintext highlighter-rouge">强连通图</code>：任意两顶点间都有来回$(v_i\leftrightarrow v_j)$路径的有向图</li>
          <li><code class="language-plaintext highlighter-rouge">强连通分量</code>：不是强连通图的有向图中符合强连通图的性质的子图
<img src="https://s2.loli.net/2022/11/23/B1KrDlZEWjoifut.png" alt="连通分量示例" /></li>
        </ul>
      </li>
    </ul>
  </li>
  <li> 
    <ul>
      <li><code class="language-plaintext highlighter-rouge">有向树</code>：满足下列条件的有向图
        <ol>
          <li>有且仅有一个结点入度为0</li>
          <li>除根外的结点入度为1</li>
          <li>从根到任一节点只有一条有向通路</li>
        </ol>
      </li>
      <li><code class="language-plaintext highlighter-rouge">生成树</code>：对连通图进行遍历，过程中所经过的边和顶点的组合构成的树
        <ul>
          <li><code class="language-plaintext highlighter-rouge">生成森林</code>：非连通图的生成树的集合</li>
        </ul>
      </li>
      <li><code class="language-plaintext highlighter-rouge">稀疏图，稠密图</code>：一个比较模糊的概念，稀疏图大概是$e&lt; nlog_{2}{n}$的图，就是边远少于点的图，反之就是稠密图</li>
    </ul>
  </li>
</ul>

<h3 id="最小生成树">最小生成树</h3>

<p>最小生成树可能不唯一</p>

<h4 id="定义-1">定义</h4>

<p>在遍历连通网时，总权值最小的生成树</p>

<h4 id="求最小生成树">求最小生成树</h4>

<h5 id="原理">原理</h5>

<ul>
  <li>一棵生成树与对应的图有如下性质：
    <ul>
      <li>图的所有顶点都在生成树中</li>
      <li>生成树的边的数量为n-1</li>
    </ul>
  </li>
</ul>

<p>所以由此可得</p>

<ul>
  <li>要构造一棵最小生成树
    <ul>
      <li>将图中的边按权值升序排列</li>
      <li>按次序选出不成环且覆盖所有顶点的边的集合</li>
      <li>选到n-1条边的时候结束（因为大于n-1的时候一定成环）</li>
    </ul>
  </li>
</ul>

<p>这里是无后效性的，贪就完事了</p>

<p>Prim是从顶点开始，而Kruskal是从边开始</p>

<p>所以才有稠密稀疏适用性不同的说法</p>

<h5 id="prim算法">Prim算法</h5>

<p>稠密图适用</p>

<p><img src="https://s2.loli.net/2022/11/28/IGzn5AjM3sKFfrZ.gif" alt="Prim动图" /></p>

<h6 id="步骤">步骤</h6>

<ul>
  <li>$A$为空集，选择任一顶点移到$A$中
    <ol>
      <li>找出边$\left(v_i,v_j \right)$满足
        <ul>
          <li>$v_i\in A \oplus v_j\in A$</li>
          <li>权值最小</li>
        </ul>
      </li>
      <li>将该边连接的顶点加入A中</li>
      <li>跳到1，直至A为全部顶点的集合，恰好可以找到N-1条边</li>
    </ol>
  </li>
  <li>这样遍历出来的树就是一棵最小生成树</li>
</ul>

<h5 id="kruskal算法">Kruskal算法</h5>

<p>稀疏图适用</p>

<p><img src="https://s2.loli.net/2022/11/28/O2I1SpUWsR6m7L3.gif" alt="Kruskal动图" /></p>

<h6 id="步骤-1">步骤</h6>

<ul>
  <li>$A$为空集
    <ol>
      <li>找出边$\left(v_i,v_j \right)$满足
        <ul>
          <li>$\neg(v_i\in A \wedge v_j\in A)$</li>
          <li>权值最小</li>
        </ul>
      </li>
      <li>将该边连接的顶点加入A中</li>
      <li>跳到1，直至A为全部顶点的集合，恰好可以找到N-1条边</li>
    </ol>
  </li>
  <li>这样遍历出来的树就是一棵最小生成树</li>
</ul>

<hr />

<h2 id="存储结构">存储结构</h2>

<p>存储稠密图时，使用邻接矩阵<br />
存储稀疏图时，使用邻接表</p>

<h3 id="邻接矩阵">邻接矩阵</h3>

<h4 id="定义-2">定义</h4>

<p>设$G(V,E)$是具有$n$个顶点的图，则$G$的邻接矩阵是具有如下性质的$n$阶方阵：</p>

\[\begin{align*}
A[i][j]= \left \{
\begin{array}{ll}
  1 ,      &amp;若\left&lt;v_i,v_j\right&gt;或(v_i,v_j) \in E\\
  0 ,\quad &amp;反之
\end{array}
\right.
\end{align*}\]

<p>说人话就是<br />
建立一个$n\times n$的矩阵<br />
如果$v_i$和$v_j$有边（弧）的话<br />
就在$[i,j]$的位置上标1，反之标0<br />
如果是网<br />
那么就标权值，反之标$\infty$<br />
（$\infty$为编程中允许的，比任何权值都大的数）</p>

<ul>
  <li><em>无向图</em><br />
<img src="https://s2.loli.net/2023/03/16/TDiLmeIfydUuWAh.png" alt="无向图矩阵" />
    <ul>
      <li>无向图的邻接矩阵是个对称矩阵</li>
    </ul>
  </li>
  <li><em>有向图</em><br />
<img src="https://s2.loli.net/2023/03/16/dBo16MZSxnXJj3A.png" alt="有向图矩阵" /></li>
</ul>

<h5 id="存储表示">存储表示</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//---图的邻接矩阵存储表示---//</span>
<span class="cp">#define MaxInt 32767//极大值
#define MVNum 100//最大顶点数
</span><span class="k">typedef</span> <span class="kt">char</span> <span class="n">VerTexType</span><span class="p">;</span><span class="c1">//数据类型</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">ArcType</span><span class="p">;</span><span class="c1">//权值类型</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
  <span class="n">VerTexType</span> <span class="n">vexs</span> <span class="p">[</span><span class="n">MVNum</span><span class="p">]</span> <span class="p">;</span><span class="c1">//顶点表</span>
  <span class="n">ArcType</span> <span class="n">arcs</span><span class="p">[</span><span class="n">MVNum</span><span class="p">][</span><span class="n">MVNum</span><span class="p">]</span> <span class="p">;</span><span class="c1">//邻接矩阵</span>
  <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span> <span class="n">arcnum</span><span class="p">;</span><span class="c1">//图的点数和边数</span>
<span class="p">}</span><span class="n">AMGraph</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="优缺点">优缺点</h4>

<ul>
  <li>优点
    <ul>
      <li>便于判断两顶点是否有边</li>
      <li>便于计算顶点的度</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>不便于增删顶点</li>
      <li>不便于统计边的数目</li>
      <li>空间复杂度高</li>
    </ul>
  </li>
</ul>

<h3 id="邻接表">邻接表</h3>

<h4 id="定义-3">定义</h4>

<blockquote>
  <p>邻接表反映的是顶点的出度邻接情况<br />
逆邻接表反映了顶点的入度邻接情况<br />
以下是邻接表的示例</p>
</blockquote>

<ol>
  <li>将所有顶点存储到线性表中</li>
  <li>为每个顶点配备一个单链表</li>
  <li>在该单链表中存储该顶点关联边（弧）的信息</li>
</ol>

<p><img src="https://s2.loli.net/2022/11/25/G1g3VUNASKPDbMY.png" alt="邻接表示例" /></p>

<p>如图<br />
以顶点$V_1$为例，它的单链表中有两个结点<br />
存储的值分别是2和1<br />
2,1分别是$V_3$,$V_2$顶点在线性表中的下标<br />
两节点分别表示$\left&lt;V1, V3\right&gt;,\left&lt;V1, V2\right&gt;$两条弧。</p>

<h5 id="节点构成">节点构成</h5>

<p><img src="https://s2.loli.net/2022/11/27/2gF3XBr5L1zCTmt.png" alt="邻接表节点示例" /></p>

<ul>
  <li>顶点节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">data</code>：存一些没啥用的信息</li>
      <li><code class="language-plaintext highlighter-rouge">first</code>：指向链表第一个元素</li>
    </ul>
  </li>
  <li>弧节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">adjvex</code>：弧头下标</li>
      <li><code class="language-plaintext highlighter-rouge">nextarc</code>：链表的下一个元素</li>
      <li><code class="language-plaintext highlighter-rouge">info</code>：一些信息（可能是权值）</li>
    </ul>
  </li>
</ul>

<h5 id="存储表示-1">存储表示</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//---图的邻接表存储表示---//</span>
<span class="cp">#define MVNum 100//最大顶点数
</span><span class="k">typedef</span> <span class="k">struct</span> <span class="nc">ArcNode</span><span class="p">{</span><span class="c1">//边</span>
  <span class="kt">int</span> <span class="n">adjvex</span><span class="p">;</span><span class="c1">//该边所指向的顶点</span>
  <span class="k">struct</span> <span class="nc">ArcNode</span> <span class="o">*</span><span class="n">nextarc</span><span class="p">;</span><span class="c1">//指向下一条边</span>
  <span class="n">OtherInfo</span> <span class="n">info</span><span class="p">;</span><span class="c1">//信息（比如权重）</span>
<span class="p">}</span><span class="n">ArcNode</span><span class="p">;</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">VNode</span><span class="p">{</span><span class="c1">//顶点</span>
  <span class="n">VerTexType</span> <span class="n">data</span><span class="p">;</span><span class="c1">//顶点信息</span>
  <span class="n">ArcNode</span> <span class="o">*</span><span class="n">firstarc</span><span class="p">;</span><span class="c1">//指向第一条边</span>
<span class="p">}</span><span class="n">VNode</span><span class="p">,</span> <span class="n">AdjList</span><span class="p">[</span><span class="n">MVNum</span><span class="p">];</span><span class="c1">//AdjList表示邻接表类型</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
  <span class="n">AdjList</span> <span class="n">vertices</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span> <span class="n">arcnum</span><span class="p">;</span><span class="c1">//图的顶点数和边数</span>
<span class="p">}</span><span class="n">ALGraph</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="优缺点-1">优缺点</h4>

<ul>
  <li>优点
    <ul>
      <li>便于增删顶点</li>
      <li>便于统计边的数目</li>
      <li>空间复杂度低</li>
    </ul>
  </li>
  <li>缺点
    <ul>
      <li>不便于判断两顶点是否有边</li>
      <li>不便于计算顶点的度</li>
    </ul>
  </li>
</ul>

<h3 id="十字链表">十字链表</h3>

<p>最好用来存储有向图</p>

<h4 id="定义-4">定义</h4>

<p>邻接表和逆邻接表的结合</p>

<ol>
  <li>将所有顶点存储到线性表中</li>
  <li>为每个顶点配备两个单链表</li>
  <li>一个链表记录以当前顶点为弧头的弧<br />
另一个链表记录以当前顶点为弧尾的弧</li>
  <li>每条边有两个指向下一条关联边的指针（见下，节点构成）</li>
</ol>

<p><img src="https://s2.loli.net/2022/11/27/PHuUzsrTvKS7Q2g.png" alt="十字链表示例" /></p>

<p>可能会有个疑问，<strong>在这张图片中</strong><br />
十字链表各个节点到底是怎么指的这么乱的?<br />
其实，该图中的节点是以<br />
弧尾下标为行<br />
弧头下标为列<br />
进行排列的</p>

<p>所以，节点的指向先从线性表开始<br />
该行的弧全是以该顶点为弧尾的弧</p>

<p>然后，再从线性表依次看<br />
将firstin指向该顶点作为弧头对应的列的第一个弧节点</p>

<p>最后，竖着看，从上到下把弧节点连起来<br />
该列的弧全是以该弧头为弧头的弧<br />
这张图中的整个表就构建完了</p>

<p>其实在真实情况下它不一定给你按照从小到大，从左到右的顺序输入<br />
这个时候就是先输入的先被连接<br />
当一个弧节点被输入进来时<br />
先将其接到对应<strong>弧尾</strong>的顶点节点的<strong>tlink</strong>链表的最末端<br />
后将其接到对应<strong>弧头</strong>的顶点节点的<strong>hlink</strong>链表的最末端<br />
节点就添加完成了</p>

<p>代码和逻辑不复杂<br />
就是加弧的时候分别在两个顶点的尾链表和头链表push<br />
但是画成图就很复杂<br />
看起来就是错综复杂到处飞线的样子</p>

<p>结合了邻接矩阵和邻接表的优点</p>

<h5 id="节点构成-1">节点构成</h5>

<p><img src="https://s2.loli.net/2022/11/27/IblPkqwxpjJWEo4.png" alt="十字链表节点" /></p>

<ul>
  <li>顶点节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">data</code>：存一些没啥用的信息</li>
      <li><code class="language-plaintext highlighter-rouge">firstin</code>：第一条以当前顶点为弧头的弧</li>
      <li><code class="language-plaintext highlighter-rouge">firstout</code>：第一条以当前顶点为弧尾的弧</li>
    </ul>
  </li>
  <li>弧节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">tailvex</code>：弧尾下标</li>
      <li><code class="language-plaintext highlighter-rouge">headvex</code>：弧头下标</li>
      <li><code class="language-plaintext highlighter-rouge">hlink</code>：弧头相同的下一条弧</li>
      <li><code class="language-plaintext highlighter-rouge">tlink</code>：弧尾相同的下一条弧</li>
      <li><code class="language-plaintext highlighter-rouge">info</code>：一些信息（可能是权值）</li>
    </ul>
  </li>
</ul>

<p>这里写成”thht”而非”thth”是因为在画图理线的时候比较顺</p>

<h5 id="存储表示-2">存储表示</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//---图的十字链表存储表示---//</span>
<span class="cp">#define  MAX_VERTEX_NUM 20 //图中顶点的最大数量
</span><span class="c1">//弧结点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">ArcBox</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">tailvex</span><span class="p">,</span> <span class="n">headvex</span><span class="p">;</span>          <span class="c1">//弧尾、弧头下标</span>
    <span class="k">struct</span> <span class="nc">ArcBox</span><span class="o">*</span> <span class="n">hlink</span><span class="p">,</span> <span class="o">*</span> <span class="n">tlink</span><span class="p">;</span>  
    <span class="n">InfoType</span> <span class="n">info</span><span class="p">;</span>               <span class="c1">//存储弧相关信息的指针</span>
<span class="p">}</span><span class="n">ArcBox</span><span class="p">;</span>
<span class="c1">//顶点节点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">VexNode</span> <span class="p">{</span>
    <span class="n">VertexType</span> <span class="n">data</span><span class="p">;</span>              <span class="c1">//顶点的数据域</span>
    <span class="n">ArcBox</span><span class="o">*</span> <span class="n">firstin</span><span class="p">,</span> <span class="o">*</span> <span class="n">firstout</span><span class="p">;</span>  
<span class="p">}</span><span class="n">VexNode</span><span class="p">;</span>
<span class="c1">//十字链表</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">VexNode</span> <span class="n">xlist</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span>  <span class="c1">//存储顶点的顺序表</span>
    <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span> <span class="n">arcnum</span><span class="p">;</span>             <span class="c1">//顶点数和弧数</span>
<span class="p">}</span><span class="n">OLGraph</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="邻接多重表">邻接多重表</h3>

<p>专门存储<strong>无向图</strong>的存储结构</p>

<p>因为在邻接表中存储无向图的时候<br />
一条边被存储了两次<br />
这样会存在很多的重复空间和操作<br />
于是邻接多重表就诞生了</p>

<h4 id="定义-5">定义</h4>

<ol>
  <li>将所有顶点存储到线性表中</li>
  <li>为每个顶点配备一个单链表</li>
  <li>在该单链表中存储该顶点关联边的信息</li>
  <li>每条边有两个指向下一条关联边的指针（见下，节点构成）</li>
</ol>

<ul>
  <li>邻接表存储无向图<br />
<img src="https://s2.loli.net/2022/11/27/XVsUZJqbTw93IPi.png" alt="邻接表存储无向图" /></li>
  <li>邻接多重表存储无向图<br />
<img src="https://s2.loli.net/2022/11/27/XuOhcsaM6T4miD3.png" alt="邻接多重表存储无向图" /></li>
</ul>

<p>和十字链表的理解是差不多的<br />
也是加边的时候分别在两个相关顶点的链表push</p>

<h5 id="节点构成-2">节点构成</h5>

<p><img src="https://s2.loli.net/2022/11/27/wZ7yW1AEq6Rso3f.png" alt="邻接多重表顶点节点" /><br />
<img src="https://s2.loli.net/2022/11/27/ObtwMec8E6W1Dz3.png" alt="邻接多重表边节点" /></p>

<ul>
  <li>顶点节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">data</code>：存一些没啥用的信息</li>
      <li><code class="language-plaintext highlighter-rouge">firstedge</code>：第一条与该顶点关联的边</li>
    </ul>
  </li>
  <li>弧节点
    <ul>
      <li><code class="language-plaintext highlighter-rouge">mark</code>：待补充……（这个书上说的是访问标记，避免重复遍历用的）</li>
      <li><code class="language-plaintext highlighter-rouge">ivex,jvex</code>：与该边有关的两顶点</li>
      <li><code class="language-plaintext highlighter-rouge">ilink</code>：下一个与ivex有关的边</li>
      <li><code class="language-plaintext highlighter-rouge">jlink</code>：下一个与jvex有关的边</li>
      <li><code class="language-plaintext highlighter-rouge">info</code>：存储一些信息，比如权值</li>
    </ul>
  </li>
</ul>

<h5 id="存储表示-3">存储表示</h5>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MAX_VERTEX_NUM 20                      //图中顶点的最大数量
</span><span class="k">typedef</span> <span class="k">enum</span> <span class="p">{</span> <span class="n">unvisited</span><span class="p">,</span> <span class="n">visited</span> <span class="p">}</span><span class="n">VisitIf</span><span class="p">;</span>    <span class="c1">//边标志域</span>
<span class="c1">//表示链表中的各个结点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">EBox</span> <span class="p">{</span>
    <span class="n">VisitIf</span> <span class="n">mark</span><span class="p">;</span>                            <span class="c1">//标志域</span>
    <span class="kt">int</span> <span class="n">ivex</span><span class="p">,</span> <span class="n">jvex</span><span class="p">;</span>                          <span class="c1">//边两边顶点在顺序表中的位置下标</span>
    <span class="k">struct</span> <span class="nc">EBox</span><span class="o">*</span> <span class="n">ilink</span><span class="p">,</span> <span class="o">*</span> <span class="n">jlink</span><span class="p">;</span>             <span class="c1">//分别指向与ivex、jvex相关的下一个边结点</span>
    <span class="n">InfoType</span><span class="o">*</span> <span class="n">info</span><span class="p">;</span>                          <span class="c1">//边的其它信息</span>
<span class="p">}</span><span class="n">EBox</span><span class="p">;</span>
<span class="c1">//存储图中的各个顶点</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="nc">VexBox</span> <span class="p">{</span>
    <span class="n">VertexType</span> <span class="n">data</span><span class="p">;</span>                        <span class="c1">//顶点数据域</span>
    <span class="n">EBox</span><span class="o">*</span> <span class="n">firstedge</span><span class="p">;</span>                        <span class="c1">//指向当前顶点对应的链表</span>
<span class="p">}</span><span class="n">VexBox</span><span class="p">;</span>
<span class="c1">//表示邻接多重表结构</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">VexBox</span> <span class="n">adjmulist</span><span class="p">[</span><span class="n">MAX_VERTEX_NUM</span><span class="p">];</span> <span class="c1">//存储图中顶点的顺序表</span>
    <span class="kt">int</span> <span class="n">vexnum</span><span class="p">,</span> <span class="n">edgenum</span><span class="p">;</span>              <span class="c1">//记录图中的顶点数量和边数量</span>
<span class="p">}</span><span class="n">AMLGraph</span><span class="p">;</span>
</code></pre></div></div>

<hr />

<h2 id="最短路径算法">最短路径算法</h2>

<p><a href="../算法/最短路/@序言">最短路径算法</a></p>

<p>两顶点路径中总权值最小的一条路径称为最短路径</p>


                    <!-- 一个用于添加作者和提交时间的文件 -->
<span style="
color: #b5d3ca;
font-style: italic;
font-family: YouYuan;
top:100px;
display: none;"
id="modified-data-footer">
    <hr></hr>
    <center>
        最后编辑时间：2023-09-28T22:31:04Z
    </center>
</span>

<script>
    var git_url="https://api.github.com/repos/dsx137/DNote/";
    var pageURL = decodeURIComponent(window.location.href);
    var footer_time = document.getElementById("modified-data-footer");
    pageURL = ("_"+pageURL.substring(pageURL.indexOf("notes/"),pageURL.length)).replace(new RegExp("#.*"),"")+".md";
    function enableElement(element){
        element.getAttributeNode("style").value=element.getAttributeNode("style").value.replace("display: none","display: block");
    }
    function footer_enable_func(curCommit){
        if(curCommit){
            var commitDate=curCommit.commit.author.date;
            var commitAuthor=curCommit.commit.author.name
            if(commitDate)
                {
                    enableElement(footer_time);
                    footer_time.innerHTML="<hr></hr><center>作者："+commitAuthor+"<br>"+"最后提交时间："+commitDate+"</center>";
                }
        }
    }


        enableElement(footer_time);
        window.addEventListener('pageChangeEvent',function(e){
            var math = document.getElementsByClassName("hidden_panel");
            if(MathJax.Hub) MathJax.Hub.Queue(["Typeset",MathJax.Hub,math]);
        });

</script>

                    
                </section>
            </div><div class="search-results">
    <div class="has-results">
        <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
        <ul class="search-results-list"></ul>
    </div>
    <div class="no-results">
        <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
    </div>
</div></div>
    </div>
</div>


<script src="/DNote/old_jekyll/assets/modified_files/mobileFingerMenu.js"></script>
<script src="/DNote/old_jekyll/assets/modified_files/tableDiv.js"></script>
                        <a href="/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.%E6%A0%91" class="navigation navigation-prev navigation-unique" aria-label="Previous page: 1.树">
                            <i class="fa fa-angle-left"></i>
                        </a>
                    

                    
                        <a href="/DNote/old_jekyll/notes/%E7%AC%94%E8%AE%B0/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%A0%86" class="navigation navigation-next navigation-unique" aria-label="Next page: 堆">
                            <i class="fa fa-angle-right"></i>
                        </a>
                    

                </div>
            </div>

            <script>
            var gitbook = gitbook || [];
            gitbook.push(function() {
                gitbook.page.hasChanged({
    "page": {
        "title": "Introduction",
        "level": "1.1",
        "depth": 1,
        
        "next": {
            "title": "堆",
            "level": "1.2",
            "depth": 1,
            "path": "_notes/笔记/数据结构/堆.md",
            "ref": "_notes/笔记/数据结构/堆.md",
            "articles": []
        },
        
        "dir": "ltr"
    },    "config": {
        "plugins": ["fontsettings", "highlight", "livereload", "lunr", "search", "sharing", "theme-default", "livereload"],
        "styles": {
            "ebook": "styles/ebook.css",
            "epub": "styles/epub.css",
            "mobi": "styles/mobi.css",
            "pdf": "styles/pdf.css",
            "print": "styles/print.css",
            "website": "styles/website.css"
        },
        "pluginsConfig": {
            "fontsettings": {
                "family": "sans",
                "size": 2,
                "theme": "night"
            },
            "highlight": {},
            "livereload": {},
            "lunr": {
                "ignoreSpecialCharacters": false,
                "maxIndexSize": 1000000
            },
            "search": {},            "sharing": {
                
            },
"theme-default": {
                "showLevel": false,
                "styles": {
                    "ebook": "styles/ebook.css",
                    "epub": "styles/epub.css",
                    "mobi": "styles/mobi.css",
                    "pdf": "styles/pdf.css",
                    "print": "styles/print.css",
                    "website": "styles/website.css"
                }
            }
        },
        "theme": "default",
        "author": "Tao He",
        "pdf": {
            "pageNumbers": true,
            "fontSize": 12,
            "fontFamily": "Arial",
            "paperSize": "a4",
            "chapterMark": "pagebreak",
            "pageBreaksBefore": "/",
            "margin": {
                "right": 62,
                "left": 62,
                "top": 56,
                "bottom": 56
            }
        },
        "structure": {
            "langs": "LANGS.md",
            "readme": "README.md",
        },
        "variables": {},
        "title": "DNote",
        "language": "en",
        "gitbook": "*"
    },
    "file": {
        "path": "_notes/笔记/数据结构/2.图.md",
        "mtime": "2023-09-28 22:31:10 +0000",
        "type": "markdown"
    },
    "gitbook": {
        "version": "3.2.3",
        "time": "2023-09-28 22:31:10 +0000"
    },
    "basePath": "/DNote/old_jekyll",
    "book": {
        "language": ""
    }
});
            });
            </script>
        </div><script src="/DNote/old_jekyll/assets/gitbook/gitbook.js"></script>
<script src="/DNote/old_jekyll/assets/gitbook/theme.js"></script>

<script src="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
<script src="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-sharing/buttons.js"></script>

<!-- <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
<script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
<script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
<script src="../gitbook/gitbook-plugin-search/search.js"></script> -->

<script src="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
<script src="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-search-pro/search.js"></script>
<script src="/DNote/old_jekyll/assets/gitbook/gitbook-plugin-back-to-top-button/plugin.js"></script>

<script type="text/javascript" id="MathJax-script" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS_HTML"></script>

</body>
    
</html>